((typeof self !== 'undefined' ? self : this)["webpackJsonpDocGen"] = (typeof self !== 'undefined' ? self : this)["webpackJsonpDocGen"] || []).push([[0],{

/***/ "051a":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.escape = exports.encodeHTML = exports.encodeXML = void 0;
var xml_json_1 = __importDefault(__webpack_require__("f5f2"));
var inverseXML = getInverseObj(xml_json_1.default);
var xmlReplacer = getInverseReplacer(inverseXML);
exports.encodeXML = getInverse(inverseXML, xmlReplacer);
var entities_json_1 = __importDefault(__webpack_require__("c560"));
var inverseHTML = getInverseObj(entities_json_1.default);
var htmlReplacer = getInverseReplacer(inverseHTML);
exports.encodeHTML = getInverse(inverseHTML, htmlReplacer);
function getInverseObj(obj) {
    return Object.keys(obj)
        .sort()
        .reduce(function (inverse, name) {
        inverse[obj[name]] = "&" + name + ";";
        return inverse;
    }, {});
}
function getInverseReplacer(inverse) {
    var single = [];
    var multiple = [];
    for (var _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {
        var k = _a[_i];
        if (k.length === 1) {
            // Add value to single array
            single.push("\\" + k);
        }
        else {
            // Add value to multiple array
            multiple.push(k);
        }
    }
    // Add ranges to single characters.
    single.sort();
    for (var start = 0; start < single.length - 1; start++) {
        // Find the end of a run of characters
        var end = start;
        while (end < single.length - 1 &&
            single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1)) {
            end += 1;
        }
        var count = 1 + end - start;
        // We want to replace at least three characters
        if (count < 3)
            continue;
        single.splice(start, count, single[start] + "-" + single[end]);
    }
    multiple.unshift("[" + single.join("") + "]");
    return new RegExp(multiple.join("|"), "g");
}
var reNonASCII = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g;
function singleCharReplacer(c) {
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    return "&#x" + c.codePointAt(0).toString(16).toUpperCase() + ";";
}
function getInverse(inverse, re) {
    return function (data) {
        return data
            .replace(re, function (name) { return inverse[name]; })
            .replace(reNonASCII, singleCharReplacer);
    };
}
var reXmlChars = getInverseReplacer(inverseXML);
function escape(data) {
    return data
        .replace(reXmlChars, singleCharReplacer)
        .replace(reNonASCII, singleCharReplacer);
}
exports.escape = escape;


/***/ }),

/***/ "2504":
/***/ (function(module) {

module.exports = JSON.parse("{\"0\":65533,\"128\":8364,\"130\":8218,\"131\":402,\"132\":8222,\"133\":8230,\"134\":8224,\"135\":8225,\"136\":710,\"137\":8240,\"138\":352,\"139\":8249,\"140\":338,\"142\":381,\"145\":8216,\"146\":8217,\"147\":8220,\"148\":8221,\"149\":8226,\"150\":8211,\"151\":8212,\"152\":732,\"153\":8482,\"154\":353,\"155\":8250,\"156\":339,\"158\":382,\"159\":376}");

/***/ }),

/***/ "2c44":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _mini_css_extract_plugin_dist_loader_js_ref_6_oneOf_1_0_css_loader_dist_cjs_js_ref_6_oneOf_1_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_6_oneOf_1_2_cache_loader_dist_cjs_js_ref_0_0_vue_loader_lib_index_js_vue_loader_options_Description_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("7a18");
/* harmony import */ var _mini_css_extract_plugin_dist_loader_js_ref_6_oneOf_1_0_css_loader_dist_cjs_js_ref_6_oneOf_1_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_6_oneOf_1_2_cache_loader_dist_cjs_js_ref_0_0_vue_loader_lib_index_js_vue_loader_options_Description_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_mini_css_extract_plugin_dist_loader_js_ref_6_oneOf_1_0_css_loader_dist_cjs_js_ref_6_oneOf_1_1_vue_loader_lib_loaders_stylePostLoader_js_postcss_loader_src_index_js_ref_6_oneOf_1_2_cache_loader_dist_cjs_js_ref_0_0_vue_loader_lib_index_js_vue_loader_options_Description_vue_vue_type_style_index_0_lang_css___WEBPACK_IMPORTED_MODULE_0__);
/* unused harmony reexport * */


/***/ }),

/***/ "7073":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var decode_json_1 = __importDefault(__webpack_require__("2504"));
// modified version of https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119
function decodeCodePoint(codePoint) {
    if ((codePoint >= 0xd800 && codePoint <= 0xdfff) || codePoint > 0x10ffff) {
        return "\uFFFD";
    }
    if (codePoint in decode_json_1.default) {
        codePoint = decode_json_1.default[codePoint];
    }
    var output = "";
    if (codePoint > 0xffff) {
        codePoint -= 0x10000;
        output += String.fromCharCode(((codePoint >>> 10) & 0x3ff) | 0xd800);
        codePoint = 0xdc00 | (codePoint & 0x3ff);
    }
    output += String.fromCharCode(codePoint);
    return output;
}
exports.default = decodeCodePoint;


/***/ }),

/***/ "7a18":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "8088":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"7b654269-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./node_modules/@openeo/vue-components/components/Description.vue?vue&type=template&id=93f3ddca&
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"vue-component styled-description",class:{compact: _vm.compact},domProps:{"innerHTML":_vm._s(_vm.markup(_vm.description))}})}
var staticRenderFns = []


// CONCATENATED MODULE: ./node_modules/@openeo/vue-components/components/Description.vue?vue&type=template&id=93f3ddca&

// CONCATENATED MODULE: ./node_modules/commonmark/lib/node.js


function isContainer(node) {
    switch (node._type) {
        case "document":
        case "block_quote":
        case "list":
        case "item":
        case "paragraph":
        case "heading":
        case "emph":
        case "strong":
        case "link":
        case "image":
        case "custom_inline":
        case "custom_block":
            return true;
        default:
            return false;
    }
}

var resumeAt = function(node, entering) {
    this.current = node;
    this.entering = entering === true;
};

var node_next = function() {
    var cur = this.current;
    var entering = this.entering;

    if (cur === null) {
        return null;
    }

    var container = isContainer(cur);

    if (entering && container) {
        if (cur._firstChild) {
            this.current = cur._firstChild;
            this.entering = true;
        } else {
            // stay on node but exit
            this.entering = false;
        }
    } else if (cur === this.root) {
        this.current = null;
    } else if (cur._next === null) {
        this.current = cur._parent;
        this.entering = false;
    } else {
        this.current = cur._next;
        this.entering = true;
    }

    return { entering: entering, node: cur };
};

var NodeWalker = function(root) {
    return {
        current: root,
        root: root,
        entering: true,
        next: node_next,
        resumeAt: resumeAt
    };
};

var Node = function(nodeType, sourcepos) {
    this._type = nodeType;
    this._parent = null;
    this._firstChild = null;
    this._lastChild = null;
    this._prev = null;
    this._next = null;
    this._sourcepos = sourcepos;
    this._lastLineBlank = false;
    this._lastLineChecked = false;
    this._open = true;
    this._string_content = null;
    this._literal = null;
    this._listData = {};
    this._info = null;
    this._destination = null;
    this._title = null;
    this._isFenced = false;
    this._fenceChar = null;
    this._fenceLength = 0;
    this._fenceOffset = null;
    this._level = null;
    this._onEnter = null;
    this._onExit = null;
};

var proto = Node.prototype;

Object.defineProperty(proto, "isContainer", {
    get: function() {
        return isContainer(this);
    }
});

Object.defineProperty(proto, "type", {
    get: function() {
        return this._type;
    }
});

Object.defineProperty(proto, "firstChild", {
    get: function() {
        return this._firstChild;
    }
});

Object.defineProperty(proto, "lastChild", {
    get: function() {
        return this._lastChild;
    }
});

Object.defineProperty(proto, "next", {
    get: function() {
        return this._next;
    }
});

Object.defineProperty(proto, "prev", {
    get: function() {
        return this._prev;
    }
});

Object.defineProperty(proto, "parent", {
    get: function() {
        return this._parent;
    }
});

Object.defineProperty(proto, "sourcepos", {
    get: function() {
        return this._sourcepos;
    }
});

Object.defineProperty(proto, "literal", {
    get: function() {
        return this._literal;
    },
    set: function(s) {
        this._literal = s;
    }
});

Object.defineProperty(proto, "destination", {
    get: function() {
        return this._destination;
    },
    set: function(s) {
        this._destination = s;
    }
});

Object.defineProperty(proto, "title", {
    get: function() {
        return this._title;
    },
    set: function(s) {
        this._title = s;
    }
});

Object.defineProperty(proto, "info", {
    get: function() {
        return this._info;
    },
    set: function(s) {
        this._info = s;
    }
});

Object.defineProperty(proto, "level", {
    get: function() {
        return this._level;
    },
    set: function(s) {
        this._level = s;
    }
});

Object.defineProperty(proto, "listType", {
    get: function() {
        return this._listData.type;
    },
    set: function(t) {
        this._listData.type = t;
    }
});

Object.defineProperty(proto, "listTight", {
    get: function() {
        return this._listData.tight;
    },
    set: function(t) {
        this._listData.tight = t;
    }
});

Object.defineProperty(proto, "listStart", {
    get: function() {
        return this._listData.start;
    },
    set: function(n) {
        this._listData.start = n;
    }
});

Object.defineProperty(proto, "listDelimiter", {
    get: function() {
        return this._listData.delimiter;
    },
    set: function(delim) {
        this._listData.delimiter = delim;
    }
});

Object.defineProperty(proto, "onEnter", {
    get: function() {
        return this._onEnter;
    },
    set: function(s) {
        this._onEnter = s;
    }
});

Object.defineProperty(proto, "onExit", {
    get: function() {
        return this._onExit;
    },
    set: function(s) {
        this._onExit = s;
    }
});

Node.prototype.appendChild = function(child) {
    child.unlink();
    child._parent = this;
    if (this._lastChild) {
        this._lastChild._next = child;
        child._prev = this._lastChild;
        this._lastChild = child;
    } else {
        this._firstChild = child;
        this._lastChild = child;
    }
};

Node.prototype.prependChild = function(child) {
    child.unlink();
    child._parent = this;
    if (this._firstChild) {
        this._firstChild._prev = child;
        child._next = this._firstChild;
        this._firstChild = child;
    } else {
        this._firstChild = child;
        this._lastChild = child;
    }
};

Node.prototype.unlink = function() {
    if (this._prev) {
        this._prev._next = this._next;
    } else if (this._parent) {
        this._parent._firstChild = this._next;
    }
    if (this._next) {
        this._next._prev = this._prev;
    } else if (this._parent) {
        this._parent._lastChild = this._prev;
    }
    this._parent = null;
    this._next = null;
    this._prev = null;
};

Node.prototype.insertAfter = function(sibling) {
    sibling.unlink();
    sibling._next = this._next;
    if (sibling._next) {
        sibling._next._prev = sibling;
    }
    sibling._prev = this;
    this._next = sibling;
    sibling._parent = this._parent;
    if (!sibling._next) {
        sibling._parent._lastChild = sibling;
    }
};

Node.prototype.insertBefore = function(sibling) {
    sibling.unlink();
    sibling._prev = this._prev;
    if (sibling._prev) {
        sibling._prev._next = sibling;
    }
    sibling._next = this;
    this._prev = sibling;
    sibling._parent = this._parent;
    if (!sibling._prev) {
        sibling._parent._firstChild = sibling;
    }
};

Node.prototype.walker = function() {
    var walker = new NodeWalker(this);
    return walker;
};

/* harmony default export */ var lib_node = (Node);

/* Example of use of walker:

 var walker = w.walker();
 var event;

 while (event = walker.next()) {
 console.log(event.entering, event.node.type);
 }

 */

// EXTERNAL MODULE: ./node_modules/mdurl/encode.js
var encode = __webpack_require__("c464");
var encode_default = /*#__PURE__*/__webpack_require__.n(encode);

// EXTERNAL MODULE: ./node_modules/entities/lib/index.js
var lib = __webpack_require__("89b6");

// CONCATENATED MODULE: ./node_modules/commonmark/lib/common.js





var C_BACKSLASH = 92;

var ENTITY = "&(?:#x[a-f0-9]{1,6}|#[0-9]{1,7}|[a-z][a-z0-9]{1,31});";

var TAGNAME = "[A-Za-z][A-Za-z0-9-]*";
var ATTRIBUTENAME = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
var UNQUOTEDVALUE = "[^\"'=<>`\\x00-\\x20]+";
var SINGLEQUOTEDVALUE = "'[^']*'";
var DOUBLEQUOTEDVALUE = '"[^"]*"';
var ATTRIBUTEVALUE =
    "(?:" +
    UNQUOTEDVALUE +
    "|" +
    SINGLEQUOTEDVALUE +
    "|" +
    DOUBLEQUOTEDVALUE +
    ")";
var ATTRIBUTEVALUESPEC = "(?:" + "\\s*=" + "\\s*" + ATTRIBUTEVALUE + ")";
var ATTRIBUTE = "(?:" + "\\s+" + ATTRIBUTENAME + ATTRIBUTEVALUESPEC + "?)";
var OPENTAG = "<" + TAGNAME + ATTRIBUTE + "*" + "\\s*/?>";
var CLOSETAG = "</" + TAGNAME + "\\s*[>]";
var HTMLCOMMENT = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->";
var PROCESSINGINSTRUCTION = "[<][?][\\s\\S]*?[?][>]";
var DECLARATION = "<![A-Z]+" + "\\s+[^>]*>";
var CDATA = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
var HTMLTAG =
    "(?:" +
    OPENTAG +
    "|" +
    CLOSETAG +
    "|" +
    HTMLCOMMENT +
    "|" +
    PROCESSINGINSTRUCTION +
    "|" +
    DECLARATION +
    "|" +
    CDATA +
    ")";
var reHtmlTag = new RegExp("^" + HTMLTAG);

var reBackslashOrAmp = /[\\&]/;

var ESCAPABLE = "[!\"#$%&'()*+,./:;<=>?@[\\\\\\]^_`{|}~-]";

var reEntityOrEscapedChar = new RegExp("\\\\" + ESCAPABLE + "|" + ENTITY, "gi");

var XMLSPECIAL = '[&<>"]';

var reXmlSpecial = new RegExp(XMLSPECIAL, "g");

var unescapeChar = function(s) {
    if (s.charCodeAt(0) === C_BACKSLASH) {
        return s.charAt(1);
    } else {
        return Object(lib["decodeHTML"])(s);
    }
};

// Replace entities and backslash escapes with literal characters.
var unescapeString = function(s) {
    if (reBackslashOrAmp.test(s)) {
        return s.replace(reEntityOrEscapedChar, unescapeChar);
    } else {
        return s;
    }
};

var normalizeURI = function(uri) {
    try {
        return encode_default()(uri);
    } catch (err) {
        return uri;
    }
};

var replaceUnsafeChar = function(s) {
    switch (s) {
        case "&":
            return "&amp;";
        case "<":
            return "&lt;";
        case ">":
            return "&gt;";
        case '"':
            return "&quot;";
        default:
            return s;
    }
};

var escapeXml = function(s) {
    if (reXmlSpecial.test(s)) {
        return s.replace(reXmlSpecial, replaceUnsafeChar);
    } else {
        return s;
    }
};



// CONCATENATED MODULE: ./node_modules/commonmark/lib/from-code-point.js


// derived from https://github.com/mathiasbynens/String.fromCodePoint
/*! http://mths.be/fromcodepoint v0.2.1 by @mathias */

var _fromCodePoint;

function fromCodePoint(_) {
    return _fromCodePoint(_);
}

if (String.fromCodePoint) {
    _fromCodePoint = function(_) {
        try {
            return String.fromCodePoint(_);
        } catch (e) {
            if (e instanceof RangeError) {
                return String.fromCharCode(0xfffd);
            }
            throw e;
        }
    };
} else {
    var stringFromCharCode = String.fromCharCode;
    var floor = Math.floor;
    _fromCodePoint = function() {
        var MAX_SIZE = 0x4000;
        var codeUnits = [];
        var highSurrogate;
        var lowSurrogate;
        var index = -1;
        var length = arguments.length;
        if (!length) {
            return "";
        }
        var result = "";
        while (++index < length) {
            var codePoint = Number(arguments[index]);
            if (
                !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
                codePoint < 0 || // not a valid Unicode code point
                codePoint > 0x10ffff || // not a valid Unicode code point
                floor(codePoint) !== codePoint // not an integer
            ) {
                return String.fromCharCode(0xfffd);
            }
            if (codePoint <= 0xffff) {
                // BMP code point
                codeUnits.push(codePoint);
            } else {
                // Astral code point; split in surrogate halves
                // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
                codePoint -= 0x10000;
                highSurrogate = (codePoint >> 10) + 0xd800;
                lowSurrogate = (codePoint % 0x400) + 0xdc00;
                codeUnits.push(highSurrogate, lowSurrogate);
            }
            if (index + 1 === length || codeUnits.length > MAX_SIZE) {
                result += stringFromCharCode.apply(null, codeUnits);
                codeUnits.length = 0;
            }
        }
        return result;
    };
}

// EXTERNAL MODULE: ./node_modules/string.prototype.repeat/repeat.js
var repeat = __webpack_require__("ed22");

// CONCATENATED MODULE: ./node_modules/commonmark/lib/inlines.js






 // Polyfill for String.prototype.repeat

var inlines_normalizeURI = normalizeURI;
var inlines_unescapeString = unescapeString;

// Constants for character codes:

var C_NEWLINE = 10;
var C_ASTERISK = 42;
var C_UNDERSCORE = 95;
var C_BACKTICK = 96;
var C_OPEN_BRACKET = 91;
var C_CLOSE_BRACKET = 93;
var C_LESSTHAN = 60;
var C_BANG = 33;
var inlines_C_BACKSLASH = 92;
var C_AMPERSAND = 38;
var C_OPEN_PAREN = 40;
var C_CLOSE_PAREN = 41;
var C_COLON = 58;
var C_SINGLEQUOTE = 39;
var C_DOUBLEQUOTE = 34;

// Some regexps used in inline parser:

var inlines_ESCAPABLE = ESCAPABLE;
var ESCAPED_CHAR = "\\\\" + inlines_ESCAPABLE;

var inlines_ENTITY = ENTITY;
var inlines_reHtmlTag = reHtmlTag;

var rePunctuation = new RegExp(
    /[!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E42\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDF3C-\uDF3E]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]/
);

var reLinkTitle = new RegExp(
    '^(?:"(' +
        ESCAPED_CHAR +
        '|[^"\\x00])*"' +
        "|" +
        "'(" +
        ESCAPED_CHAR +
        "|[^'\\x00])*'" +
        "|" +
        "\\((" +
        ESCAPED_CHAR +
        "|[^()\\x00])*\\))"
);

var reLinkDestinationBraces = /^(?:<(?:[^<>\n\\\x00]|\\.)*>)/;

var reEscapable = new RegExp("^" + inlines_ESCAPABLE);

var reEntityHere = new RegExp("^" + inlines_ENTITY, "i");

var reTicks = /`+/;

var reTicksHere = /^`+/;

var reEllipses = /\.\.\./g;

var reDash = /--+/g;

var reEmailAutolink = /^<([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;

var reAutolink = /^<[A-Za-z][A-Za-z0-9.+-]{1,31}:[^<>\x00-\x20]*>/i;

var reSpnl = /^ *(?:\n *)?/;

var reWhitespaceChar = /^[ \t\n\x0b\x0c\x0d]/;

var reUnicodeWhitespaceChar = /^\s/;

var reFinalSpace = / *$/;

var reInitialSpace = /^ */;

var reSpaceAtEndOfLine = /^ *(?:\n|$)/;

var reLinkLabel = /^\[(?:[^\\\[\]]|\\.){0,1000}\]/;

// Matches a string of non-special characters.
var reMain = /^[^\n`\[\]\\!<&*_'"]+/m;

var inlines_text = function(s) {
    var node = new lib_node("text");
    node._literal = s;
    return node;
};

// normalize a reference in reference link (remove []s, trim,
// collapse internal space, unicode case fold.
// See commonmark/commonmark.js#168.
var normalizeReference = function(string) {
    return string
        .slice(1, string.length - 1)
        .trim()
        .replace(/[ \t\r\n]+/, " ")
        .toLowerCase()
        .toUpperCase();
};

// INLINE PARSER

// These are methods of an InlineParser object, defined below.
// An InlineParser keeps track of a subject (a string to be
// parsed) and a position in that subject.

// If re matches at current position in the subject, advance
// position in subject and return the match; otherwise return null.
var inlines_match = function(re) {
    var m = re.exec(this.subject.slice(this.pos));
    if (m === null) {
        return null;
    } else {
        this.pos += m.index + m[0].length;
        return m[0];
    }
};

// Returns the code for the character at the current subject position, or -1
// there are no more characters.
var peek = function() {
    if (this.pos < this.subject.length) {
        return this.subject.charCodeAt(this.pos);
    } else {
        return -1;
    }
};

// Parse zero or more space characters, including at most one newline
var spnl = function() {
    this.match(reSpnl);
    return true;
};

// All of the parsers below try to match something at the current position
// in the subject.  If they succeed in matching anything, they
// return the inline matched, advancing the subject.

// Attempt to parse backticks, adding either a backtick code span or a
// literal sequence of backticks.
var parseBackticks = function(block) {
    var ticks = this.match(reTicksHere);
    if (ticks === null) {
        return false;
    }
    var afterOpenTicks = this.pos;
    var matched;
    var node;
    var contents;
    while ((matched = this.match(reTicks)) !== null) {
        if (matched === ticks) {
            node = new lib_node("code");
            contents = this.subject
                .slice(afterOpenTicks, this.pos - ticks.length)
                .replace(/\n/gm, " ");
            if (
                contents.length > 0 &&
                contents.match(/[^ ]/) !== null &&
                contents[0] == " " &&
                contents[contents.length - 1] == " "
            ) {
                node._literal = contents.slice(1, contents.length - 1);
            } else {
                node._literal = contents;
            }
            block.appendChild(node);
            return true;
        }
    }
    // If we got here, we didn't match a closing backtick sequence.
    this.pos = afterOpenTicks;
    block.appendChild(inlines_text(ticks));
    return true;
};

// Parse a backslash-escaped special character, adding either the escaped
// character, a hard line break (if the backslash is followed by a newline),
// or a literal backslash to the block's children.  Assumes current character
// is a backslash.
var parseBackslash = function(block) {
    var subj = this.subject;
    var node;
    this.pos += 1;
    if (this.peek() === C_NEWLINE) {
        this.pos += 1;
        node = new lib_node("linebreak");
        block.appendChild(node);
    } else if (reEscapable.test(subj.charAt(this.pos))) {
        block.appendChild(inlines_text(subj.charAt(this.pos)));
        this.pos += 1;
    } else {
        block.appendChild(inlines_text("\\"));
    }
    return true;
};

// Attempt to parse an autolink (URL or email in pointy brackets).
var parseAutolink = function(block) {
    var m;
    var dest;
    var node;
    if ((m = this.match(reEmailAutolink))) {
        dest = m.slice(1, m.length - 1);
        node = new lib_node("link");
        node._destination = inlines_normalizeURI("mailto:" + dest);
        node._title = "";
        node.appendChild(inlines_text(dest));
        block.appendChild(node);
        return true;
    } else if ((m = this.match(reAutolink))) {
        dest = m.slice(1, m.length - 1);
        node = new lib_node("link");
        node._destination = inlines_normalizeURI(dest);
        node._title = "";
        node.appendChild(inlines_text(dest));
        block.appendChild(node);
        return true;
    } else {
        return false;
    }
};

// Attempt to parse a raw HTML tag.
var parseHtmlTag = function(block) {
    var m = this.match(inlines_reHtmlTag);
    if (m === null) {
        return false;
    } else {
        var node = new lib_node("html_inline");
        node._literal = m;
        block.appendChild(node);
        return true;
    }
};

// Scan a sequence of characters with code cc, and return information about
// the number of delimiters and whether they are positioned such that
// they can open and/or close emphasis or strong emphasis.  A utility
// function for strong/emph parsing.
var scanDelims = function(cc) {
    var numdelims = 0;
    var char_before, char_after, cc_after;
    var startpos = this.pos;
    var left_flanking, right_flanking, can_open, can_close;
    var after_is_whitespace,
        after_is_punctuation,
        before_is_whitespace,
        before_is_punctuation;

    if (cc === C_SINGLEQUOTE || cc === C_DOUBLEQUOTE) {
        numdelims++;
        this.pos++;
    } else {
        while (this.peek() === cc) {
            numdelims++;
            this.pos++;
        }
    }

    if (numdelims === 0) {
        return null;
    }

    char_before = startpos === 0 ? "\n" : this.subject.charAt(startpos - 1);

    cc_after = this.peek();
    if (cc_after === -1) {
        char_after = "\n";
    } else {
        char_after = fromCodePoint(cc_after);
    }

    after_is_whitespace = reUnicodeWhitespaceChar.test(char_after);
    after_is_punctuation = rePunctuation.test(char_after);
    before_is_whitespace = reUnicodeWhitespaceChar.test(char_before);
    before_is_punctuation = rePunctuation.test(char_before);

    left_flanking =
        !after_is_whitespace &&
        (!after_is_punctuation ||
            before_is_whitespace ||
            before_is_punctuation);
    right_flanking =
        !before_is_whitespace &&
        (!before_is_punctuation || after_is_whitespace || after_is_punctuation);
    if (cc === C_UNDERSCORE) {
        can_open = left_flanking && (!right_flanking || before_is_punctuation);
        can_close = right_flanking && (!left_flanking || after_is_punctuation);
    } else if (cc === C_SINGLEQUOTE || cc === C_DOUBLEQUOTE) {
        can_open = left_flanking && !right_flanking;
        can_close = right_flanking;
    } else {
        can_open = left_flanking;
        can_close = right_flanking;
    }
    this.pos = startpos;
    return { numdelims: numdelims, can_open: can_open, can_close: can_close };
};

// Handle a delimiter marker for emphasis or a quote.
var handleDelim = function(cc, block) {
    var res = this.scanDelims(cc);
    if (!res) {
        return false;
    }
    var numdelims = res.numdelims;
    var startpos = this.pos;
    var contents;

    this.pos += numdelims;
    if (cc === C_SINGLEQUOTE) {
        contents = "\u2019";
    } else if (cc === C_DOUBLEQUOTE) {
        contents = "\u201C";
    } else {
        contents = this.subject.slice(startpos, this.pos);
    }
    var node = inlines_text(contents);
    block.appendChild(node);

    // Add entry to stack for this opener
    if (
        (res.can_open || res.can_close) &&
        (this.options.smart || (cc !== C_SINGLEQUOTE && cc !== C_DOUBLEQUOTE))
    ) {
        this.delimiters = {
            cc: cc,
            numdelims: numdelims,
            origdelims: numdelims,
            node: node,
            previous: this.delimiters,
            next: null,
            can_open: res.can_open,
            can_close: res.can_close
        };
        if (this.delimiters.previous !== null) {
            this.delimiters.previous.next = this.delimiters;
        }
    }

    return true;
};

var removeDelimiter = function(delim) {
    if (delim.previous !== null) {
        delim.previous.next = delim.next;
    }
    if (delim.next === null) {
        // top of stack
        this.delimiters = delim.previous;
    } else {
        delim.next.previous = delim.previous;
    }
};

var removeDelimitersBetween = function(bottom, top) {
    if (bottom.next !== top) {
        bottom.next = top;
        top.previous = bottom;
    }
};

var processEmphasis = function(stack_bottom) {
    var opener, closer, old_closer;
    var opener_inl, closer_inl;
    var tempstack;
    var use_delims;
    var tmp, next;
    var opener_found;
    var openers_bottom = [[], [], []];
    var odd_match = false;

    for (var i = 0; i < 3; i++) {
        openers_bottom[i][C_UNDERSCORE] = stack_bottom;
        openers_bottom[i][C_ASTERISK] = stack_bottom;
        openers_bottom[i][C_SINGLEQUOTE] = stack_bottom;
        openers_bottom[i][C_DOUBLEQUOTE] = stack_bottom;
    }
    // find first closer above stack_bottom:
    closer = this.delimiters;
    while (closer !== null && closer.previous !== stack_bottom) {
        closer = closer.previous;
    }
    // move forward, looking for closers, and handling each
    while (closer !== null) {
        var closercc = closer.cc;
        if (!closer.can_close) {
            closer = closer.next;
        } else {
            // found emphasis closer. now look back for first matching opener:
            opener = closer.previous;
            opener_found = false;
            while (
                opener !== null &&
                opener !== stack_bottom &&
                opener !== openers_bottom[closer.origdelims % 3][closercc]
            ) {
                odd_match =
                    (closer.can_open || opener.can_close) &&
                    closer.origdelims % 3 !== 0 &&
                    (opener.origdelims + closer.origdelims) % 3 === 0;
                if (opener.cc === closer.cc && opener.can_open && !odd_match) {
                    opener_found = true;
                    break;
                }
                opener = opener.previous;
            }
            old_closer = closer;

            if (closercc === C_ASTERISK || closercc === C_UNDERSCORE) {
                if (!opener_found) {
                    closer = closer.next;
                } else {
                    // calculate actual number of delimiters used from closer
                    use_delims =
                        closer.numdelims >= 2 && opener.numdelims >= 2 ? 2 : 1;

                    opener_inl = opener.node;
                    closer_inl = closer.node;

                    // remove used delimiters from stack elts and inlines
                    opener.numdelims -= use_delims;
                    closer.numdelims -= use_delims;
                    opener_inl._literal = opener_inl._literal.slice(
                        0,
                        opener_inl._literal.length - use_delims
                    );
                    closer_inl._literal = closer_inl._literal.slice(
                        0,
                        closer_inl._literal.length - use_delims
                    );

                    // build contents for new emph element
                    var emph = new lib_node(use_delims === 1 ? "emph" : "strong");

                    tmp = opener_inl._next;
                    while (tmp && tmp !== closer_inl) {
                        next = tmp._next;
                        tmp.unlink();
                        emph.appendChild(tmp);
                        tmp = next;
                    }

                    opener_inl.insertAfter(emph);

                    // remove elts between opener and closer in delimiters stack
                    removeDelimitersBetween(opener, closer);

                    // if opener has 0 delims, remove it and the inline
                    if (opener.numdelims === 0) {
                        opener_inl.unlink();
                        this.removeDelimiter(opener);
                    }

                    if (closer.numdelims === 0) {
                        closer_inl.unlink();
                        tempstack = closer.next;
                        this.removeDelimiter(closer);
                        closer = tempstack;
                    }
                }
            } else if (closercc === C_SINGLEQUOTE) {
                closer.node._literal = "\u2019";
                if (opener_found) {
                    opener.node._literal = "\u2018";
                }
                closer = closer.next;
            } else if (closercc === C_DOUBLEQUOTE) {
                closer.node._literal = "\u201D";
                if (opener_found) {
                    opener.node.literal = "\u201C";
                }
                closer = closer.next;
            }
            if (!opener_found) {
                // Set lower bound for future searches for openers:
                openers_bottom[old_closer.origdelims % 3][closercc] =
                    old_closer.previous;
                if (!old_closer.can_open) {
                    // We can remove a closer that can't be an opener,
                    // once we've seen there's no matching opener:
                    this.removeDelimiter(old_closer);
                }
            }
        }
    }

    // remove all delimiters
    while (this.delimiters !== null && this.delimiters !== stack_bottom) {
        this.removeDelimiter(this.delimiters);
    }
};

// Attempt to parse link title (sans quotes), returning the string
// or null if no match.
var parseLinkTitle = function() {
    var title = this.match(reLinkTitle);
    if (title === null) {
        return null;
    } else {
        // chop off quotes from title and unescape:
        return inlines_unescapeString(title.substr(1, title.length - 2));
    }
};

// Attempt to parse link destination, returning the string or
// null if no match.
var parseLinkDestination = function() {
    var res = this.match(reLinkDestinationBraces);
    if (res === null) {
        if (this.peek() === C_LESSTHAN) {
            return null;
        }
        // TODO handrolled parser; res should be null or the string
        var savepos = this.pos;
        var openparens = 0;
        var c;
        while ((c = this.peek()) !== -1) {
            if (
                c === inlines_C_BACKSLASH &&
                reEscapable.test(this.subject.charAt(this.pos + 1))
            ) {
                this.pos += 1;
                if (this.peek() !== -1) {
                    this.pos += 1;
                }
            } else if (c === C_OPEN_PAREN) {
                this.pos += 1;
                openparens += 1;
            } else if (c === C_CLOSE_PAREN) {
                if (openparens < 1) {
                    break;
                } else {
                    this.pos += 1;
                    openparens -= 1;
                }
            } else if (reWhitespaceChar.exec(fromCodePoint(c)) !== null) {
                break;
            } else {
                this.pos += 1;
            }
        }
        if (this.pos === savepos && c !== C_CLOSE_PAREN) {
            return null;
        }
        if (openparens !== 0) {
            return null;
        }
        res = this.subject.substr(savepos, this.pos - savepos);
        return inlines_normalizeURI(inlines_unescapeString(res));
    } else {
        // chop off surrounding <..>:
        return inlines_normalizeURI(inlines_unescapeString(res.substr(1, res.length - 2)));
    }
};

// Attempt to parse a link label, returning number of characters parsed.
var parseLinkLabel = function() {
    var m = this.match(reLinkLabel);
    if (m === null || m.length > 1001) {
        return 0;
    } else {
        return m.length;
    }
};

// Add open bracket to delimiter stack and add a text node to block's children.
var parseOpenBracket = function(block) {
    var startpos = this.pos;
    this.pos += 1;

    var node = inlines_text("[");
    block.appendChild(node);

    // Add entry to stack for this opener
    this.addBracket(node, startpos, false);
    return true;
};

// IF next character is [, and ! delimiter to delimiter stack and
// add a text node to block's children.  Otherwise just add a text node.
var parseBang = function(block) {
    var startpos = this.pos;
    this.pos += 1;
    if (this.peek() === C_OPEN_BRACKET) {
        this.pos += 1;

        var node = inlines_text("![");
        block.appendChild(node);

        // Add entry to stack for this opener
        this.addBracket(node, startpos + 1, true);
    } else {
        block.appendChild(inlines_text("!"));
    }
    return true;
};

// Try to match close bracket against an opening in the delimiter
// stack.  Add either a link or image, or a plain [ character,
// to block's children.  If there is a matching delimiter,
// remove it from the delimiter stack.
var parseCloseBracket = function(block) {
    var startpos;
    var is_image;
    var dest;
    var title;
    var matched = false;
    var reflabel;
    var opener;

    this.pos += 1;
    startpos = this.pos;

    // get last [ or ![
    opener = this.brackets;

    if (opener === null) {
        // no matched opener, just return a literal
        block.appendChild(inlines_text("]"));
        return true;
    }

    if (!opener.active) {
        // no matched opener, just return a literal
        block.appendChild(inlines_text("]"));
        // take opener off brackets stack
        this.removeBracket();
        return true;
    }

    // If we got here, open is a potential opener
    is_image = opener.image;

    // Check to see if we have a link/image

    var savepos = this.pos;

    // Inline link?
    if (this.peek() === C_OPEN_PAREN) {
        this.pos++;
        if (
            this.spnl() &&
            (dest = this.parseLinkDestination()) !== null &&
            this.spnl() &&
            // make sure there's a space before the title:
            ((reWhitespaceChar.test(this.subject.charAt(this.pos - 1)) &&
                (title = this.parseLinkTitle())) ||
                true) &&
            this.spnl() &&
            this.peek() === C_CLOSE_PAREN
        ) {
            this.pos += 1;
            matched = true;
        } else {
            this.pos = savepos;
        }
    }

    if (!matched) {
        // Next, see if there's a link label
        var beforelabel = this.pos;
        var n = this.parseLinkLabel();
        if (n > 2) {
            reflabel = this.subject.slice(beforelabel, beforelabel + n);
        } else if (!opener.bracketAfter) {
            // Empty or missing second label means to use the first label as the reference.
            // The reference must not contain a bracket. If we know there's a bracket, we don't even bother checking it.
            reflabel = this.subject.slice(opener.index, startpos);
        }
        if (n === 0) {
            // If shortcut reference link, rewind before spaces we skipped.
            this.pos = savepos;
        }

        if (reflabel) {
            // lookup rawlabel in refmap
            var link = this.refmap[normalizeReference(reflabel)];
            if (link) {
                dest = link.destination;
                title = link.title;
                matched = true;
            }
        }
    }

    if (matched) {
        var node = new lib_node(is_image ? "image" : "link");
        node._destination = dest;
        node._title = title || "";

        var tmp, next;
        tmp = opener.node._next;
        while (tmp) {
            next = tmp._next;
            tmp.unlink();
            node.appendChild(tmp);
            tmp = next;
        }
        block.appendChild(node);
        this.processEmphasis(opener.previousDelimiter);
        this.removeBracket();
        opener.node.unlink();

        // We remove this bracket and processEmphasis will remove later delimiters.
        // Now, for a link, we also deactivate earlier link openers.
        // (no links in links)
        if (!is_image) {
            opener = this.brackets;
            while (opener !== null) {
                if (!opener.image) {
                    opener.active = false; // deactivate this opener
                }
                opener = opener.previous;
            }
        }

        return true;
    } else {
        // no match

        this.removeBracket(); // remove this opener from stack
        this.pos = startpos;
        block.appendChild(inlines_text("]"));
        return true;
    }
};

var addBracket = function(node, index, image) {
    if (this.brackets !== null) {
        this.brackets.bracketAfter = true;
    }
    this.brackets = {
        node: node,
        previous: this.brackets,
        previousDelimiter: this.delimiters,
        index: index,
        image: image,
        active: true
    };
};

var removeBracket = function() {
    this.brackets = this.brackets.previous;
};

// Attempt to parse an entity.
var parseEntity = function(block) {
    var m;
    if ((m = this.match(reEntityHere))) {
        block.appendChild(inlines_text(Object(lib["decodeHTML"])(m)));
        return true;
    } else {
        return false;
    }
};

// Parse a run of ordinary characters, or a single character with
// a special meaning in markdown, as a plain string.
var parseString = function(block) {
    var m;
    if ((m = this.match(reMain))) {
        if (this.options.smart) {
            block.appendChild(
                inlines_text(
                    m
                        .replace(reEllipses, "\u2026")
                        .replace(reDash, function(chars) {
                            var enCount = 0;
                            var emCount = 0;
                            if (chars.length % 3 === 0) {
                                // If divisible by 3, use all em dashes
                                emCount = chars.length / 3;
                            } else if (chars.length % 2 === 0) {
                                // If divisible by 2, use all en dashes
                                enCount = chars.length / 2;
                            } else if (chars.length % 3 === 2) {
                                // If 2 extra dashes, use en dash for last 2; em dashes for rest
                                enCount = 1;
                                emCount = (chars.length - 2) / 3;
                            } else {
                                // Use en dashes for last 4 hyphens; em dashes for rest
                                enCount = 2;
                                emCount = (chars.length - 4) / 3;
                            }
                            return (
                                "\u2014".repeat(emCount) +
                                "\u2013".repeat(enCount)
                            );
                        })
                )
            );
        } else {
            block.appendChild(inlines_text(m));
        }
        return true;
    } else {
        return false;
    }
};

// Parse a newline.  If it was preceded by two spaces, return a hard
// line break; otherwise a soft line break.
var parseNewline = function(block) {
    this.pos += 1; // assume we're at a \n
    // check previous node for trailing spaces
    var lastc = block._lastChild;
    if (
        lastc &&
        lastc.type === "text" &&
        lastc._literal[lastc._literal.length - 1] === " "
    ) {
        var hardbreak = lastc._literal[lastc._literal.length - 2] === " ";
        lastc._literal = lastc._literal.replace(reFinalSpace, "");
        block.appendChild(new lib_node(hardbreak ? "linebreak" : "softbreak"));
    } else {
        block.appendChild(new lib_node("softbreak"));
    }
    this.match(reInitialSpace); // gobble leading spaces in next line
    return true;
};

// Attempt to parse a link reference, modifying refmap.
var parseReference = function(s, refmap) {
    this.subject = s;
    this.pos = 0;
    var rawlabel;
    var dest;
    var title;
    var matchChars;
    var startpos = this.pos;

    // label:
    matchChars = this.parseLinkLabel();
    if (matchChars === 0) {
        return 0;
    } else {
        rawlabel = this.subject.substr(0, matchChars);
    }

    // colon:
    if (this.peek() === C_COLON) {
        this.pos++;
    } else {
        this.pos = startpos;
        return 0;
    }

    //  link url
    this.spnl();

    dest = this.parseLinkDestination();
    if (dest === null) {
        this.pos = startpos;
        return 0;
    }

    var beforetitle = this.pos;
    this.spnl();
    if (this.pos !== beforetitle) {
        title = this.parseLinkTitle();
    }
    if (title === null) {
        title = "";
        // rewind before spaces
        this.pos = beforetitle;
    }

    // make sure we're at line end:
    var atLineEnd = true;
    if (this.match(reSpaceAtEndOfLine) === null) {
        if (title === "") {
            atLineEnd = false;
        } else {
            // the potential title we found is not at the line end,
            // but it could still be a legal link reference if we
            // discard the title
            title = "";
            // rewind before spaces
            this.pos = beforetitle;
            // and instead check if the link URL is at the line end
            atLineEnd = this.match(reSpaceAtEndOfLine) !== null;
        }
    }

    if (!atLineEnd) {
        this.pos = startpos;
        return 0;
    }

    var normlabel = normalizeReference(rawlabel);
    if (normlabel === "") {
        // label must contain non-whitespace characters
        this.pos = startpos;
        return 0;
    }

    if (!refmap[normlabel]) {
        refmap[normlabel] = { destination: dest, title: title };
    }
    return this.pos - startpos;
};

// Parse the next inline element in subject, advancing subject position.
// On success, add the result to block's children and return true.
// On failure, return false.
var parseInline = function(block) {
    var res = false;
    var c = this.peek();
    if (c === -1) {
        return false;
    }
    switch (c) {
        case C_NEWLINE:
            res = this.parseNewline(block);
            break;
        case inlines_C_BACKSLASH:
            res = this.parseBackslash(block);
            break;
        case C_BACKTICK:
            res = this.parseBackticks(block);
            break;
        case C_ASTERISK:
        case C_UNDERSCORE:
            res = this.handleDelim(c, block);
            break;
        case C_SINGLEQUOTE:
        case C_DOUBLEQUOTE:
            res = this.options.smart && this.handleDelim(c, block);
            break;
        case C_OPEN_BRACKET:
            res = this.parseOpenBracket(block);
            break;
        case C_BANG:
            res = this.parseBang(block);
            break;
        case C_CLOSE_BRACKET:
            res = this.parseCloseBracket(block);
            break;
        case C_LESSTHAN:
            res = this.parseAutolink(block) || this.parseHtmlTag(block);
            break;
        case C_AMPERSAND:
            res = this.parseEntity(block);
            break;
        default:
            res = this.parseString(block);
            break;
    }
    if (!res) {
        this.pos += 1;
        block.appendChild(inlines_text(fromCodePoint(c)));
    }

    return true;
};

// Parse string content in block into inline children,
// using refmap to resolve references.
var parseInlines = function(block) {
    this.subject = block._string_content.trim();
    this.pos = 0;
    this.delimiters = null;
    this.brackets = null;
    while (this.parseInline(block)) {}
    block._string_content = null; // allow raw string to be garbage collected
    this.processEmphasis(null);
};

// The InlineParser object.
function InlineParser(options) {
    return {
        subject: "",
        delimiters: null, // used by handleDelim method
        brackets: null,
        pos: 0,
        refmap: {},
        match: inlines_match,
        peek: peek,
        spnl: spnl,
        parseBackticks: parseBackticks,
        parseBackslash: parseBackslash,
        parseAutolink: parseAutolink,
        parseHtmlTag: parseHtmlTag,
        scanDelims: scanDelims,
        handleDelim: handleDelim,
        parseLinkTitle: parseLinkTitle,
        parseLinkDestination: parseLinkDestination,
        parseLinkLabel: parseLinkLabel,
        parseOpenBracket: parseOpenBracket,
        parseBang: parseBang,
        parseCloseBracket: parseCloseBracket,
        addBracket: addBracket,
        removeBracket: removeBracket,
        parseEntity: parseEntity,
        parseString: parseString,
        parseNewline: parseNewline,
        parseReference: parseReference,
        parseInline: parseInline,
        processEmphasis: processEmphasis,
        removeDelimiter: removeDelimiter,
        options: options || {},
        parse: parseInlines
    };
}

/* harmony default export */ var inlines = (InlineParser);

// CONCATENATED MODULE: ./node_modules/commonmark/lib/blocks.js






var CODE_INDENT = 4;

var C_TAB = 9;
var blocks_C_NEWLINE = 10;
var C_GREATERTHAN = 62;
var blocks_C_LESSTHAN = 60;
var C_SPACE = 32;
var blocks_C_OPEN_BRACKET = 91;

var reHtmlBlockOpen = [
    /./, // dummy for 0
    /^<(?:script|pre|textarea|style)(?:\s|>|$)/i,
    /^<!--/,
    /^<[?]/,
    /^<![A-Z]/,
    /^<!\[CDATA\[/,
    /^<[/]?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[123456]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\s|[/]?[>]|$)/i,
    new RegExp("^(?:" + OPENTAG + "|" + CLOSETAG + ")\\s*$", "i")
];

var reHtmlBlockClose = [
    /./, // dummy for 0
    /<\/(?:script|pre|textarea|style)>/i,
    /-->/,
    /\?>/,
    />/,
    /\]\]>/
];

var reThematicBreak = /^(?:(?:\*[ \t]*){3,}|(?:_[ \t]*){3,}|(?:-[ \t]*){3,})[ \t]*$/;

var reMaybeSpecial = /^[#`~*+_=<>0-9-]/;

var reNonSpace = /[^ \t\f\v\r\n]/;

var reBulletListMarker = /^[*+-]/;

var reOrderedListMarker = /^(\d{1,9})([.)])/;

var reATXHeadingMarker = /^#{1,6}(?:[ \t]+|$)/;

var reCodeFence = /^`{3,}(?!.*`)|^~{3,}/;

var reClosingCodeFence = /^(?:`{3,}|~{3,})(?= *$)/;

var reSetextHeadingLine = /^(?:=+|-+)[ \t]*$/;

var reLineEnding = /\r\n|\n|\r/;

// Returns true if string contains only space characters.
var isBlank = function(s) {
    return !reNonSpace.test(s);
};

var isSpaceOrTab = function(c) {
    return c === C_SPACE || c === C_TAB;
};

var blocks_peek = function(ln, pos) {
    if (pos < ln.length) {
        return ln.charCodeAt(pos);
    } else {
        return -1;
    }
};

// DOC PARSER

// These are methods of a Parser object, defined below.

// Returns true if block ends with a blank line, descending if needed
// into lists and sublists.
var endsWithBlankLine = function(block) {
    while (block) {
        if (block._lastLineBlank) {
            return true;
        }
        var t = block.type;
        if (!block._lastLineChecked && (t === "list" || t === "item")) {
            block._lastLineChecked = true;
            block = block._lastChild;
        } else {
            block._lastLineChecked = true;
            break;
        }
    }
    return false;
};

// Add a line to the block at the tip.  We assume the tip
// can accept lines -- that check should be done before calling this.
var addLine = function() {
    if (this.partiallyConsumedTab) {
        this.offset += 1; // skip over tab
        // add space characters:
        var charsToTab = 4 - (this.column % 4);
        this.tip._string_content += " ".repeat(charsToTab);
    }
    this.tip._string_content += this.currentLine.slice(this.offset) + "\n";
};

// Add block of type tag as a child of the tip.  If the tip can't
// accept children, close and finalize it and try its parent,
// and so on til we find a block that can accept children.
var addChild = function(tag, offset) {
    while (!this.blocks[this.tip.type].canContain(tag)) {
        this.finalize(this.tip, this.lineNumber - 1);
    }

    var column_number = offset + 1; // offset 0 = column 1
    var newBlock = new lib_node(tag, [
        [this.lineNumber, column_number],
        [0, 0]
    ]);
    newBlock._string_content = "";
    this.tip.appendChild(newBlock);
    this.tip = newBlock;
    return newBlock;
};

// Parse a list marker and return data on the marker (type,
// start, delimiter, bullet character, padding) or null.
var parseListMarker = function(parser, container) {
    var rest = parser.currentLine.slice(parser.nextNonspace);
    var match;
    var nextc;
    var spacesStartCol;
    var spacesStartOffset;
    var data = {
        type: null,
        tight: true, // lists are tight by default
        bulletChar: null,
        start: null,
        delimiter: null,
        padding: null,
        markerOffset: parser.indent
    };
    if (parser.indent >= 4) {
        return null;
    }
    if ((match = rest.match(reBulletListMarker))) {
        data.type = "bullet";
        data.bulletChar = match[0][0];
    } else if (
        (match = rest.match(reOrderedListMarker)) &&
        (container.type !== "paragraph" || match[1] === "1")
    ) {
        data.type = "ordered";
        data.start = parseInt(match[1]);
        data.delimiter = match[2];
    } else {
        return null;
    }
    // make sure we have spaces after
    nextc = blocks_peek(parser.currentLine, parser.nextNonspace + match[0].length);
    if (!(nextc === -1 || nextc === C_TAB || nextc === C_SPACE)) {
        return null;
    }

    // if it interrupts paragraph, make sure first line isn't blank
    if (
        container.type === "paragraph" &&
        !parser.currentLine
            .slice(parser.nextNonspace + match[0].length)
            .match(reNonSpace)
    ) {
        return null;
    }

    // we've got a match! advance offset and calculate padding
    parser.advanceNextNonspace(); // to start of marker
    parser.advanceOffset(match[0].length, true); // to end of marker
    spacesStartCol = parser.column;
    spacesStartOffset = parser.offset;
    do {
        parser.advanceOffset(1, true);
        nextc = blocks_peek(parser.currentLine, parser.offset);
    } while (parser.column - spacesStartCol < 5 && isSpaceOrTab(nextc));
    var blank_item = blocks_peek(parser.currentLine, parser.offset) === -1;
    var spaces_after_marker = parser.column - spacesStartCol;
    if (spaces_after_marker >= 5 || spaces_after_marker < 1 || blank_item) {
        data.padding = match[0].length + 1;
        parser.column = spacesStartCol;
        parser.offset = spacesStartOffset;
        if (isSpaceOrTab(blocks_peek(parser.currentLine, parser.offset))) {
            parser.advanceOffset(1, true);
        }
    } else {
        data.padding = match[0].length + spaces_after_marker;
    }
    return data;
};

// Returns true if the two list items are of the same type,
// with the same delimiter and bullet character.  This is used
// in agglomerating list items into lists.
var listsMatch = function(list_data, item_data) {
    return (
        list_data.type === item_data.type &&
        list_data.delimiter === item_data.delimiter &&
        list_data.bulletChar === item_data.bulletChar
    );
};

// Finalize and close any unmatched blocks.
var closeUnmatchedBlocks = function() {
    if (!this.allClosed) {
        // finalize any blocks not matched
        while (this.oldtip !== this.lastMatchedContainer) {
            var parent = this.oldtip._parent;
            this.finalize(this.oldtip, this.lineNumber - 1);
            this.oldtip = parent;
        }
        this.allClosed = true;
    }
};

// 'finalize' is run when the block is closed.
// 'continue' is run to check whether the block is continuing
// at a certain line and offset (e.g. whether a block quote
// contains a `>`.  It returns 0 for matched, 1 for not matched,
// and 2 for "we've dealt with this line completely, go to next."
var blocks = {
    document: {
        continue: function() {
            return 0;
        },
        finalize: function() {
            return;
        },
        canContain: function(t) {
            return t !== "item";
        },
        acceptsLines: false
    },
    list: {
        continue: function() {
            return 0;
        },
        finalize: function(parser, block) {
            var item = block._firstChild;
            while (item) {
                // check for non-final list item ending with blank line:
                if (endsWithBlankLine(item) && item._next) {
                    block._listData.tight = false;
                    break;
                }
                // recurse into children of list item, to see if there are
                // spaces between any of them:
                var subitem = item._firstChild;
                while (subitem) {
                    if (
                        endsWithBlankLine(subitem) &&
                        (item._next || subitem._next)
                    ) {
                        block._listData.tight = false;
                        break;
                    }
                    subitem = subitem._next;
                }
                item = item._next;
            }
        },
        canContain: function(t) {
            return t === "item";
        },
        acceptsLines: false
    },
    block_quote: {
        continue: function(parser) {
            var ln = parser.currentLine;
            if (
                !parser.indented &&
                blocks_peek(ln, parser.nextNonspace) === C_GREATERTHAN
            ) {
                parser.advanceNextNonspace();
                parser.advanceOffset(1, false);
                if (isSpaceOrTab(blocks_peek(ln, parser.offset))) {
                    parser.advanceOffset(1, true);
                }
            } else {
                return 1;
            }
            return 0;
        },
        finalize: function() {
            return;
        },
        canContain: function(t) {
            return t !== "item";
        },
        acceptsLines: false
    },
    item: {
        continue: function(parser, container) {
            if (parser.blank) {
                if (container._firstChild == null) {
                    // Blank line after empty list item
                    return 1;
                } else {
                    parser.advanceNextNonspace();
                }
            } else if (
                parser.indent >=
                container._listData.markerOffset + container._listData.padding
            ) {
                parser.advanceOffset(
                    container._listData.markerOffset +
                        container._listData.padding,
                    true
                );
            } else {
                return 1;
            }
            return 0;
        },
        finalize: function() {
            return;
        },
        canContain: function(t) {
            return t !== "item";
        },
        acceptsLines: false
    },
    heading: {
        continue: function() {
            // a heading can never container > 1 line, so fail to match:
            return 1;
        },
        finalize: function() {
            return;
        },
        canContain: function() {
            return false;
        },
        acceptsLines: false
    },
    thematic_break: {
        continue: function() {
            // a thematic break can never container > 1 line, so fail to match:
            return 1;
        },
        finalize: function() {
            return;
        },
        canContain: function() {
            return false;
        },
        acceptsLines: false
    },
    code_block: {
        continue: function(parser, container) {
            var ln = parser.currentLine;
            var indent = parser.indent;
            if (container._isFenced) {
                // fenced
                var match =
                    indent <= 3 &&
                    ln.charAt(parser.nextNonspace) === container._fenceChar &&
                    ln.slice(parser.nextNonspace).match(reClosingCodeFence);
                if (match && match[0].length >= container._fenceLength) {
                    // closing fence - we're at end of line, so we can return
                    parser.lastLineLength =
                        parser.offset + indent + match[0].length;
                    parser.finalize(container, parser.lineNumber);
                    return 2;
                } else {
                    // skip optional spaces of fence offset
                    var i = container._fenceOffset;
                    while (i > 0 && isSpaceOrTab(blocks_peek(ln, parser.offset))) {
                        parser.advanceOffset(1, true);
                        i--;
                    }
                }
            } else {
                // indented
                if (indent >= CODE_INDENT) {
                    parser.advanceOffset(CODE_INDENT, true);
                } else if (parser.blank) {
                    parser.advanceNextNonspace();
                } else {
                    return 1;
                }
            }
            return 0;
        },
        finalize: function(parser, block) {
            if (block._isFenced) {
                // fenced
                // first line becomes info string
                var content = block._string_content;
                var newlinePos = content.indexOf("\n");
                var firstLine = content.slice(0, newlinePos);
                var rest = content.slice(newlinePos + 1);
                block.info = unescapeString(firstLine.trim());
                block._literal = rest;
            } else {
                // indented
                block._literal = block._string_content.replace(
                    /(\n *)+$/,
                    "\n"
                );
            }
            block._string_content = null; // allow GC
        },
        canContain: function() {
            return false;
        },
        acceptsLines: true
    },
    html_block: {
        continue: function(parser, container) {
            return parser.blank &&
                (container._htmlBlockType === 6 ||
                    container._htmlBlockType === 7)
                ? 1
                : 0;
        },
        finalize: function(parser, block) {
            block._literal = block._string_content.replace(/(\n *)+$/, "");
            block._string_content = null; // allow GC
        },
        canContain: function() {
            return false;
        },
        acceptsLines: true
    },
    paragraph: {
        continue: function(parser) {
            return parser.blank ? 1 : 0;
        },
        finalize: function(parser, block) {
            var pos;
            var hasReferenceDefs = false;

            // try parsing the beginning as link reference definitions:
            while (
                blocks_peek(block._string_content, 0) === blocks_C_OPEN_BRACKET &&
                (pos = parser.inlineParser.parseReference(
                    block._string_content,
                    parser.refmap
                ))
            ) {
                block._string_content = block._string_content.slice(pos);
                hasReferenceDefs = true;
            }
            if (hasReferenceDefs && isBlank(block._string_content)) {
                block.unlink();
            }
        },
        canContain: function() {
            return false;
        },
        acceptsLines: true
    }
};

// block start functions.  Return values:
// 0 = no match
// 1 = matched container, keep going
// 2 = matched leaf, no more block starts
var blockStarts = [
    // block quote
    function(parser) {
        if (
            !parser.indented &&
            blocks_peek(parser.currentLine, parser.nextNonspace) === C_GREATERTHAN
        ) {
            parser.advanceNextNonspace();
            parser.advanceOffset(1, false);
            // optional following space
            if (isSpaceOrTab(blocks_peek(parser.currentLine, parser.offset))) {
                parser.advanceOffset(1, true);
            }
            parser.closeUnmatchedBlocks();
            parser.addChild("block_quote", parser.nextNonspace);
            return 1;
        } else {
            return 0;
        }
    },

    // ATX heading
    function(parser) {
        var match;
        if (
            !parser.indented &&
            (match = parser.currentLine
                .slice(parser.nextNonspace)
                .match(reATXHeadingMarker))
        ) {
            parser.advanceNextNonspace();
            parser.advanceOffset(match[0].length, false);
            parser.closeUnmatchedBlocks();
            var container = parser.addChild("heading", parser.nextNonspace);
            container.level = match[0].trim().length; // number of #s
            // remove trailing ###s:
            container._string_content = parser.currentLine
                .slice(parser.offset)
                .replace(/^[ \t]*#+[ \t]*$/, "")
                .replace(/[ \t]+#+[ \t]*$/, "");
            parser.advanceOffset(parser.currentLine.length - parser.offset);
            return 2;
        } else {
            return 0;
        }
    },

    // Fenced code block
    function(parser) {
        var match;
        if (
            !parser.indented &&
            (match = parser.currentLine
                .slice(parser.nextNonspace)
                .match(reCodeFence))
        ) {
            var fenceLength = match[0].length;
            parser.closeUnmatchedBlocks();
            var container = parser.addChild("code_block", parser.nextNonspace);
            container._isFenced = true;
            container._fenceLength = fenceLength;
            container._fenceChar = match[0][0];
            container._fenceOffset = parser.indent;
            parser.advanceNextNonspace();
            parser.advanceOffset(fenceLength, false);
            return 2;
        } else {
            return 0;
        }
    },

    // HTML block
    function(parser, container) {
        if (
            !parser.indented &&
            blocks_peek(parser.currentLine, parser.nextNonspace) === blocks_C_LESSTHAN
        ) {
            var s = parser.currentLine.slice(parser.nextNonspace);
            var blockType;

            for (blockType = 1; blockType <= 7; blockType++) {
                if (
                    reHtmlBlockOpen[blockType].test(s) &&
                    (blockType < 7 || container.type !== "paragraph")
                ) {
                    parser.closeUnmatchedBlocks();
                    // We don't adjust parser.offset;
                    // spaces are part of the HTML block:
                    var b = parser.addChild("html_block", parser.offset);
                    b._htmlBlockType = blockType;
                    return 2;
                }
            }
        }

        return 0;
    },

    // Setext heading
    function(parser, container) {
        var match;
        if (
            !parser.indented &&
            container.type === "paragraph" &&
            (match = parser.currentLine
                .slice(parser.nextNonspace)
                .match(reSetextHeadingLine))
        ) {
            parser.closeUnmatchedBlocks();
            // resolve reference link definitiosn
            var pos;
            while (
                blocks_peek(container._string_content, 0) === blocks_C_OPEN_BRACKET &&
                (pos = parser.inlineParser.parseReference(
                    container._string_content,
                    parser.refmap
                ))
            ) {
                container._string_content = container._string_content.slice(
                    pos
                );
            }
            if (container._string_content.length > 0) {
                var heading = new lib_node("heading", container.sourcepos);
                heading.level = match[0][0] === "=" ? 1 : 2;
                heading._string_content = container._string_content;
                container.insertAfter(heading);
                container.unlink();
                parser.tip = heading;
                parser.advanceOffset(
                    parser.currentLine.length - parser.offset,
                    false
                );
                return 2;
            } else {
                return 0;
            }
        } else {
            return 0;
        }
    },

    // thematic break
    function(parser) {
        if (
            !parser.indented &&
            reThematicBreak.test(parser.currentLine.slice(parser.nextNonspace))
        ) {
            parser.closeUnmatchedBlocks();
            parser.addChild("thematic_break", parser.nextNonspace);
            parser.advanceOffset(
                parser.currentLine.length - parser.offset,
                false
            );
            return 2;
        } else {
            return 0;
        }
    },

    // list item
    function(parser, container) {
        var data;

        if (
            (!parser.indented || container.type === "list") &&
            (data = parseListMarker(parser, container))
        ) {
            parser.closeUnmatchedBlocks();

            // add the list if needed
            if (
                parser.tip.type !== "list" ||
                !listsMatch(container._listData, data)
            ) {
                container = parser.addChild("list", parser.nextNonspace);
                container._listData = data;
            }

            // add the list item
            container = parser.addChild("item", parser.nextNonspace);
            container._listData = data;
            return 1;
        } else {
            return 0;
        }
    },

    // indented code block
    function(parser) {
        if (
            parser.indented &&
            parser.tip.type !== "paragraph" &&
            !parser.blank
        ) {
            // indented code
            parser.advanceOffset(CODE_INDENT, true);
            parser.closeUnmatchedBlocks();
            parser.addChild("code_block", parser.offset);
            return 2;
        } else {
            return 0;
        }
    }
];

var advanceOffset = function(count, columns) {
    var currentLine = this.currentLine;
    var charsToTab, charsToAdvance;
    var c;
    while (count > 0 && (c = currentLine[this.offset])) {
        if (c === "\t") {
            charsToTab = 4 - (this.column % 4);
            if (columns) {
                this.partiallyConsumedTab = charsToTab > count;
                charsToAdvance = charsToTab > count ? count : charsToTab;
                this.column += charsToAdvance;
                this.offset += this.partiallyConsumedTab ? 0 : 1;
                count -= charsToAdvance;
            } else {
                this.partiallyConsumedTab = false;
                this.column += charsToTab;
                this.offset += 1;
                count -= 1;
            }
        } else {
            this.partiallyConsumedTab = false;
            this.offset += 1;
            this.column += 1; // assume ascii; block starts are ascii
            count -= 1;
        }
    }
};

var advanceNextNonspace = function() {
    this.offset = this.nextNonspace;
    this.column = this.nextNonspaceColumn;
    this.partiallyConsumedTab = false;
};

var findNextNonspace = function() {
    var currentLine = this.currentLine;
    var i = this.offset;
    var cols = this.column;
    var c;

    while ((c = currentLine.charAt(i)) !== "") {
        if (c === " ") {
            i++;
            cols++;
        } else if (c === "\t") {
            i++;
            cols += 4 - (cols % 4);
        } else {
            break;
        }
    }
    this.blank = c === "\n" || c === "\r" || c === "";
    this.nextNonspace = i;
    this.nextNonspaceColumn = cols;
    this.indent = this.nextNonspaceColumn - this.column;
    this.indented = this.indent >= CODE_INDENT;
};

// Analyze a line of text and update the document appropriately.
// We parse markdown text by calling this on each line of input,
// then finalizing the document.
var incorporateLine = function(ln) {
    var all_matched = true;
    var t;

    var container = this.doc;
    this.oldtip = this.tip;
    this.offset = 0;
    this.column = 0;
    this.blank = false;
    this.partiallyConsumedTab = false;
    this.lineNumber += 1;

    // replace NUL characters for security
    if (ln.indexOf("\u0000") !== -1) {
        ln = ln.replace(/\0/g, "\uFFFD");
    }

    this.currentLine = ln;

    // For each containing block, try to parse the associated line start.
    // Bail out on failure: container will point to the last matching block.
    // Set all_matched to false if not all containers match.
    var lastChild;
    while ((lastChild = container._lastChild) && lastChild._open) {
        container = lastChild;

        this.findNextNonspace();

        switch (this.blocks[container.type].continue(this, container)) {
            case 0: // we've matched, keep going
                break;
            case 1: // we've failed to match a block
                all_matched = false;
                break;
            case 2: // we've hit end of line for fenced code close and can return
                return;
            default:
                throw "continue returned illegal value, must be 0, 1, or 2";
        }
        if (!all_matched) {
            container = container._parent; // back up to last matching block
            break;
        }
    }

    this.allClosed = container === this.oldtip;
    this.lastMatchedContainer = container;

    var matchedLeaf =
        container.type !== "paragraph" && blocks[container.type].acceptsLines;
    var starts = this.blockStarts;
    var startsLen = starts.length;
    // Unless last matched container is a code block, try new container starts,
    // adding children to the last matched container:
    while (!matchedLeaf) {
        this.findNextNonspace();

        // this is a little performance optimization:
        if (
            !this.indented &&
            !reMaybeSpecial.test(ln.slice(this.nextNonspace))
        ) {
            this.advanceNextNonspace();
            break;
        }

        var i = 0;
        while (i < startsLen) {
            var res = starts[i](this, container);
            if (res === 1) {
                container = this.tip;
                break;
            } else if (res === 2) {
                container = this.tip;
                matchedLeaf = true;
                break;
            } else {
                i++;
            }
        }

        if (i === startsLen) {
            // nothing matched
            this.advanceNextNonspace();
            break;
        }
    }

    // What remains at the offset is a text line.  Add the text to the
    // appropriate container.

    // First check for a lazy paragraph continuation:
    if (!this.allClosed && !this.blank && this.tip.type === "paragraph") {
        // lazy paragraph continuation
        this.addLine();
    } else {
        // not a lazy continuation

        // finalize any blocks not matched
        this.closeUnmatchedBlocks();
        if (this.blank && container.lastChild) {
            container.lastChild._lastLineBlank = true;
        }

        t = container.type;

        // Block quote lines are never blank as they start with >
        // and we don't count blanks in fenced code for purposes of tight/loose
        // lists or breaking out of lists.  We also don't set _lastLineBlank
        // on an empty list item, or if we just closed a fenced block.
        var lastLineBlank =
            this.blank &&
            !(
                t === "block_quote" ||
                (t === "code_block" && container._isFenced) ||
                (t === "item" &&
                    !container._firstChild &&
                    container.sourcepos[0][0] === this.lineNumber)
            );

        // propagate lastLineBlank up through parents:
        var cont = container;
        while (cont) {
            cont._lastLineBlank = lastLineBlank;
            cont = cont._parent;
        }

        if (this.blocks[t].acceptsLines) {
            this.addLine();
            // if HtmlBlock, check for end condition
            if (
                t === "html_block" &&
                container._htmlBlockType >= 1 &&
                container._htmlBlockType <= 5 &&
                reHtmlBlockClose[container._htmlBlockType].test(
                    this.currentLine.slice(this.offset)
                )
            ) {
                this.lastLineLength = ln.length;
                this.finalize(container, this.lineNumber);
            }
        } else if (this.offset < ln.length && !this.blank) {
            // create paragraph container for line
            container = this.addChild("paragraph", this.offset);
            this.advanceNextNonspace();
            this.addLine();
        }
    }
    this.lastLineLength = ln.length;
};

// Finalize a block.  Close it and do any necessary postprocessing,
// e.g. creating string_content from strings, setting the 'tight'
// or 'loose' status of a list, and parsing the beginnings
// of paragraphs for reference definitions.  Reset the tip to the
// parent of the closed block.
var finalize = function(block, lineNumber) {
    var above = block._parent;
    block._open = false;
    block.sourcepos[1] = [lineNumber, this.lastLineLength];

    this.blocks[block.type].finalize(this, block);

    this.tip = above;
};

// Walk through a block & children recursively, parsing string content
// into inline content where appropriate.
var processInlines = function(block) {
    var node, event, t;
    var walker = block.walker();
    this.inlineParser.refmap = this.refmap;
    this.inlineParser.options = this.options;
    while ((event = walker.next())) {
        node = event.node;
        t = node.type;
        if (!event.entering && (t === "paragraph" || t === "heading")) {
            this.inlineParser.parse(node);
        }
    }
};

var Document = function() {
    var doc = new lib_node("document", [
        [1, 1],
        [0, 0]
    ]);
    return doc;
};

// The main parsing function.  Returns a parsed document AST.
var parse = function(input) {
    this.doc = new Document();
    this.tip = this.doc;
    this.refmap = {};
    this.lineNumber = 0;
    this.lastLineLength = 0;
    this.offset = 0;
    this.column = 0;
    this.lastMatchedContainer = this.doc;
    this.currentLine = "";
    if (this.options.time) {
        console.time("preparing input");
    }
    var lines = input.split(reLineEnding);
    var len = lines.length;
    if (input.charCodeAt(input.length - 1) === blocks_C_NEWLINE) {
        // ignore last blank line created by final newline
        len -= 1;
    }
    if (this.options.time) {
        console.timeEnd("preparing input");
    }
    if (this.options.time) {
        console.time("block parsing");
    }
    for (var i = 0; i < len; i++) {
        this.incorporateLine(lines[i]);
    }
    while (this.tip) {
        this.finalize(this.tip, len);
    }
    if (this.options.time) {
        console.timeEnd("block parsing");
    }
    if (this.options.time) {
        console.time("inline parsing");
    }
    this.processInlines(this.doc);
    if (this.options.time) {
        console.timeEnd("inline parsing");
    }
    return this.doc;
};

// The Parser object.
function Parser(options) {
    return {
        doc: new Document(),
        blocks: blocks,
        blockStarts: blockStarts,
        tip: this.doc,
        oldtip: this.doc,
        currentLine: "",
        lineNumber: 0,
        offset: 0,
        column: 0,
        nextNonspace: 0,
        nextNonspaceColumn: 0,
        indent: 0,
        indented: false,
        blank: false,
        partiallyConsumedTab: false,
        allClosed: true,
        lastMatchedContainer: this.doc,
        refmap: {},
        lastLineLength: 0,
        inlineParser: new inlines(options),
        findNextNonspace: findNextNonspace,
        advanceOffset: advanceOffset,
        advanceNextNonspace: advanceNextNonspace,
        addLine: addLine,
        addChild: addChild,
        incorporateLine: incorporateLine,
        finalize: finalize,
        processInlines: processInlines,
        closeUnmatchedBlocks: closeUnmatchedBlocks,
        parse: parse,
        options: options || {}
    };
}

/* harmony default export */ var lib_blocks = (Parser);

// CONCATENATED MODULE: ./node_modules/commonmark/lib/render/renderer.js


function Renderer() {}

/**
 *  Walks the AST and calls member methods for each Node type.
 *
 *  @param ast {Node} The root of the abstract syntax tree.
 */
function renderer_render(ast) {
    var walker = ast.walker(),
        event,
        type;

    this.buffer = "";
    this.lastOut = "\n";

    while ((event = walker.next())) {
        type = event.node.type;
        if (this[type]) {
            this[type](event.node, event.entering);
        }
    }
    return this.buffer;
}

/**
 *  Concatenate a literal string to the buffer.
 *
 *  @param str {String} The string to concatenate.
 */
function lit(str) {
    this.buffer += str;
    this.lastOut = str;
}

/**
 *  Output a newline to the buffer.
 */
function cr() {
    if (this.lastOut !== "\n") {
        this.lit("\n");
    }
}

/**
 *  Concatenate a string to the buffer possibly escaping the content.
 *
 *  Concrete renderer implementations should override this method.
 *
 *  @param str {String} The string to concatenate.
 */
function out(str) {
    this.lit(str);
}

/**
 *  Escape a string for the target renderer.
 *
 *  Abstract function that should be implemented by concrete
 *  renderer implementations.
 *
 *  @param str {String} The string to escape.
 */
function esc(str) {
    return str;
}

Renderer.prototype.render = renderer_render;
Renderer.prototype.out = out;
Renderer.prototype.lit = lit;
Renderer.prototype.cr = cr;
Renderer.prototype.esc = esc;

/* harmony default export */ var renderer = (Renderer);

// CONCATENATED MODULE: ./node_modules/commonmark/lib/render/html.js





var reUnsafeProtocol = /^javascript:|vbscript:|file:|data:/i;
var reSafeDataProtocol = /^data:image\/(?:png|gif|jpeg|webp)/i;

var potentiallyUnsafe = function(url) {
    return reUnsafeProtocol.test(url) && !reSafeDataProtocol.test(url);
};

// Helper function to produce an HTML tag.
function html_tag(name, attrs, selfclosing) {
    if (this.disableTags > 0) {
        return;
    }
    this.buffer += "<" + name;
    if (attrs && attrs.length > 0) {
        var i = 0;
        var attrib;
        while ((attrib = attrs[i]) !== undefined) {
            this.buffer += " " + attrib[0] + '="' + attrib[1] + '"';
            i++;
        }
    }
    if (selfclosing) {
        this.buffer += " /";
    }
    this.buffer += ">";
    this.lastOut = ">";
}

function HtmlRenderer(options) {
    options = options || {};
    // by default, soft breaks are rendered as newlines in HTML
    options.softbreak = options.softbreak || "\n";
    // set to "<br />" to make them hard breaks
    // set to " " if you want to ignore line wrapping in source

    this.disableTags = 0;
    this.lastOut = "\n";
    this.options = options;
}

/* Node methods */

function html_text(node) {
    this.out(node.literal);
}

function softbreak() {
    this.lit(this.options.softbreak);
}

function linebreak() {
    this.tag("br", [], true);
    this.cr();
}

function html_link(node, entering) {
    var attrs = this.attrs(node);
    if (entering) {
        if (!(this.options.safe && potentiallyUnsafe(node.destination))) {
            attrs.push(["href", this.esc(node.destination)]);
        }
        if (node.title) {
            attrs.push(["title", this.esc(node.title)]);
        }
        this.tag("a", attrs);
    } else {
        this.tag("/a");
    }
}

function html_image(node, entering) {
    if (entering) {
        if (this.disableTags === 0) {
            if (this.options.safe && potentiallyUnsafe(node.destination)) {
                this.lit('<img src="" alt="');
            } else {
                this.lit('<img src="' + this.esc(node.destination) + '" alt="');
            }
        }
        this.disableTags += 1;
    } else {
        this.disableTags -= 1;
        if (this.disableTags === 0) {
            if (node.title) {
                this.lit('" title="' + this.esc(node.title));
            }
            this.lit('" />');
        }
    }
}

function html_emph(node, entering) {
    this.tag(entering ? "em" : "/em");
}

function strong(node, entering) {
    this.tag(entering ? "strong" : "/strong");
}

function paragraph(node, entering) {
    var grandparent = node.parent.parent,
        attrs = this.attrs(node);
    if (grandparent !== null && grandparent.type === "list") {
        if (grandparent.listTight) {
            return;
        }
    }
    if (entering) {
        this.cr();
        this.tag("p", attrs);
    } else {
        this.tag("/p");
        this.cr();
    }
}

function html_heading(node, entering) {
    var tagname = "h" + node.level,
        attrs = this.attrs(node);
    if (entering) {
        this.cr();
        this.tag(tagname, attrs);
    } else {
        this.tag("/" + tagname);
        this.cr();
    }
}

function code(node) {
    this.tag("code");
    this.out(node.literal);
    this.tag("/code");
}

function code_block(node) {
    var info_words = node.info ? node.info.split(/\s+/) : [],
        attrs = this.attrs(node);
    if (info_words.length > 0 && info_words[0].length > 0) {
        attrs.push(["class", "language-" + this.esc(info_words[0])]);
    }
    this.cr();
    this.tag("pre");
    this.tag("code", attrs);
    this.out(node.literal);
    this.tag("/code");
    this.tag("/pre");
    this.cr();
}

function thematic_break(node) {
    var attrs = this.attrs(node);
    this.cr();
    this.tag("hr", attrs, true);
    this.cr();
}

function block_quote(node, entering) {
    var attrs = this.attrs(node);
    if (entering) {
        this.cr();
        this.tag("blockquote", attrs);
        this.cr();
    } else {
        this.cr();
        this.tag("/blockquote");
        this.cr();
    }
}

function list(node, entering) {
    var tagname = node.listType === "bullet" ? "ul" : "ol",
        attrs = this.attrs(node);

    if (entering) {
        var start = node.listStart;
        if (start !== null && start !== 1) {
            attrs.push(["start", start.toString()]);
        }
        this.cr();
        this.tag(tagname, attrs);
        this.cr();
    } else {
        this.cr();
        this.tag("/" + tagname);
        this.cr();
    }
}

function item(node, entering) {
    var attrs = this.attrs(node);
    if (entering) {
        this.tag("li", attrs);
    } else {
        this.tag("/li");
        this.cr();
    }
}

function html_inline(node) {
    if (this.options.safe) {
        this.lit("<!-- raw HTML omitted -->");
    } else {
        this.lit(node.literal);
    }
}

function html_block(node) {
    this.cr();
    if (this.options.safe) {
        this.lit("<!-- raw HTML omitted -->");
    } else {
        this.lit(node.literal);
    }
    this.cr();
}

function custom_inline(node, entering) {
    if (entering && node.onEnter) {
        this.lit(node.onEnter);
    } else if (!entering && node.onExit) {
        this.lit(node.onExit);
    }
}

function custom_block(node, entering) {
    this.cr();
    if (entering && node.onEnter) {
        this.lit(node.onEnter);
    } else if (!entering && node.onExit) {
        this.lit(node.onExit);
    }
    this.cr();
}

/* Helper methods */

function html_out(s) {
    this.lit(this.esc(s));
}

function attrs(node) {
    var att = [];
    if (this.options.sourcepos) {
        var pos = node.sourcepos;
        if (pos) {
            att.push([
                "data-sourcepos",
                String(pos[0][0]) +
                    ":" +
                    String(pos[0][1]) +
                    "-" +
                    String(pos[1][0]) +
                    ":" +
                    String(pos[1][1])
            ]);
        }
    }
    return att;
}

// quick browser-compatible inheritance
HtmlRenderer.prototype = Object.create(renderer.prototype);

HtmlRenderer.prototype.text = html_text;
HtmlRenderer.prototype.html_inline = html_inline;
HtmlRenderer.prototype.html_block = html_block;
HtmlRenderer.prototype.softbreak = softbreak;
HtmlRenderer.prototype.linebreak = linebreak;
HtmlRenderer.prototype.link = html_link;
HtmlRenderer.prototype.image = html_image;
HtmlRenderer.prototype.emph = html_emph;
HtmlRenderer.prototype.strong = strong;
HtmlRenderer.prototype.paragraph = paragraph;
HtmlRenderer.prototype.heading = html_heading;
HtmlRenderer.prototype.code = code;
HtmlRenderer.prototype.code_block = code_block;
HtmlRenderer.prototype.thematic_break = thematic_break;
HtmlRenderer.prototype.block_quote = block_quote;
HtmlRenderer.prototype.list = list;
HtmlRenderer.prototype.item = item;
HtmlRenderer.prototype.custom_inline = custom_inline;
HtmlRenderer.prototype.custom_block = custom_block;

HtmlRenderer.prototype.esc = escapeXml;

HtmlRenderer.prototype.out = html_out;
HtmlRenderer.prototype.tag = html_tag;
HtmlRenderer.prototype.attrs = attrs;

/* harmony default export */ var html = (HtmlRenderer);

// CONCATENATED MODULE: ./node_modules/commonmark/lib/render/xml.js





var reXMLTag = /\<[^>]*\>/;

function toTagName(s) {
    return s.replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
}

function XmlRenderer(options) {
    options = options || {};

    this.disableTags = 0;
    this.lastOut = "\n";

    this.indentLevel = 0;
    this.indent = "  ";

    this.options = options;
}

function xml_render(ast) {
    this.buffer = "";

    var attrs;
    var tagname;
    var walker = ast.walker();
    var event, node, entering;
    var container;
    var selfClosing;
    var nodetype;

    var options = this.options;

    if (options.time) {
        console.time("rendering");
    }

    this.buffer += '<?xml version="1.0" encoding="UTF-8"?>\n';
    this.buffer += '<!DOCTYPE document SYSTEM "CommonMark.dtd">\n';

    while ((event = walker.next())) {
        entering = event.entering;
        node = event.node;
        nodetype = node.type;

        container = node.isContainer;

        selfClosing =
            nodetype === "thematic_break" ||
            nodetype === "linebreak" ||
            nodetype === "softbreak";

        tagname = toTagName(nodetype);

        if (entering) {
            attrs = [];

            switch (nodetype) {
                case "document":
                    attrs.push(["xmlns", "http://commonmark.org/xml/1.0"]);
                    break;
                case "list":
                    if (node.listType !== null) {
                        attrs.push(["type", node.listType.toLowerCase()]);
                    }
                    if (node.listStart !== null) {
                        attrs.push(["start", String(node.listStart)]);
                    }
                    if (node.listTight !== null) {
                        attrs.push([
                            "tight",
                            node.listTight ? "true" : "false"
                        ]);
                    }
                    var delim = node.listDelimiter;
                    if (delim !== null) {
                        var delimword = "";
                        if (delim === ".") {
                            delimword = "period";
                        } else {
                            delimword = "paren";
                        }
                        attrs.push(["delimiter", delimword]);
                    }
                    break;
                case "code_block":
                    if (node.info) {
                        attrs.push(["info", node.info]);
                    }
                    break;
                case "heading":
                    attrs.push(["level", String(node.level)]);
                    break;
                case "link":
                case "image":
                    attrs.push(["destination", node.destination]);
                    attrs.push(["title", node.title]);
                    break;
                case "custom_inline":
                case "custom_block":
                    attrs.push(["on_enter", node.onEnter]);
                    attrs.push(["on_exit", node.onExit]);
                    break;
                default:
                    break;
            }
            if (options.sourcepos) {
                var pos = node.sourcepos;
                if (pos) {
                    attrs.push([
                        "sourcepos",
                        String(pos[0][0]) +
                            ":" +
                            String(pos[0][1]) +
                            "-" +
                            String(pos[1][0]) +
                            ":" +
                            String(pos[1][1])
                    ]);
                }
            }

            this.cr();
            this.out(this.tag(tagname, attrs, selfClosing));
            if (container) {
                this.indentLevel += 1;
            } else if (!container && !selfClosing) {
                var lit = node.literal;
                if (lit) {
                    this.out(this.esc(lit));
                }
                this.out(this.tag("/" + tagname));
            }
        } else {
            this.indentLevel -= 1;
            this.cr();
            this.out(this.tag("/" + tagname));
        }
    }
    if (options.time) {
        console.timeEnd("rendering");
    }
    this.buffer += "\n";
    return this.buffer;
}

function xml_out(s) {
    if (this.disableTags > 0) {
        this.buffer += s.replace(reXMLTag, "");
    } else {
        this.buffer += s;
    }
    this.lastOut = s;
}

function xml_cr() {
    if (this.lastOut !== "\n") {
        this.buffer += "\n";
        this.lastOut = "\n";
        for (var i = this.indentLevel; i > 0; i--) {
            this.buffer += this.indent;
        }
    }
}

// Helper function to produce an XML tag.
function xml_tag(name, attrs, selfclosing) {
    var result = "<" + name;
    if (attrs && attrs.length > 0) {
        var i = 0;
        var attrib;
        while ((attrib = attrs[i]) !== undefined) {
            result += " " + attrib[0] + '="' + this.esc(attrib[1]) + '"';
            i++;
        }
    }
    if (selfclosing) {
        result += " /";
    }
    result += ">";
    return result;
}

// quick browser-compatible inheritance
XmlRenderer.prototype = Object.create(renderer.prototype);

XmlRenderer.prototype.render = xml_render;
XmlRenderer.prototype.out = xml_out;
XmlRenderer.prototype.cr = xml_cr;
XmlRenderer.prototype.tag = xml_tag;
XmlRenderer.prototype.esc = escapeXml;

/* harmony default export */ var xml = (XmlRenderer);

// CONCATENATED MODULE: ./node_modules/commonmark/lib/index.js


// commonmark.js - CommomMark in JavaScript
// Copyright (C) 2014 John MacFarlane
// License: BSD3.

// Basic usage:
//
// import { Parser, HtmlRenderer } from 'commonmark';
// var parser = new Parser();
// var renderer = new HtmlRenderer();
// console.log(renderer.render(parser.parse('Hello *world*')));







// EXTERNAL MODULE: ./node_modules/@openeo/vue-components/utils.js + 10 modules
var utils = __webpack_require__("60a2");

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./node_modules/@openeo/vue-components/components/Description.vue?vue&type=script&lang=js&
//
//
//
//


/* harmony default export */ var Descriptionvue_type_script_lang_js_ = ({
  name: 'Description',
  props: {
    description: {
      type: String,
      default: ''
    },
    preprocessor: {
      type: Function,
      default: null
    },
    processor: {
      type: Function,
      default: null
    },
    processUrl: {
      type: String,
      default: null
    },
    compact: {
      type: Boolean,
      default: false
    },
    allowHTML: {
      type: Boolean,
      default: false
    }
  },

  beforeCreate() {
    utils["a" /* default */].enableHtmlProps(this);
  },

  methods: {
    markup(text) {
      if (typeof text !== 'string') {
        return '';
      } // Parse our extension to CommonMark, which allows linking to other processes with ``process()``
      // Temporarily replace with a non-commonmark and non-html string to avoid parsing/removal


      if (typeof this.processUrl === 'string') {
        text = text.replace(/(^|[^\w`])``(\w+)\(\)``(?![\w`])/g, (_, prefix, pid) => {
          return `${prefix}@pid:${pid}@@`;
        });
      } // Parse CommonMark


      var reader = new lib_blocks();
      var writer = new html({
        safe: !this.allowHTML,
        smart: true
      });

      if (typeof this.preprocessor === 'function') {
        text = this.preprocessor(text);
      }

      var parsed = reader.parse(text);
      var rendered = writer.render(parsed);

      if (typeof this.processor === 'function') {
        rendered = this.processor(rendered);
      } // Replace temporary replacement code with process link


      if (typeof this.processUrl === 'string') {
        rendered = rendered.replace(/@pid:(\w+)@@/g, (_, pid) => this.linkToProcess(pid));
      }

      return rendered;
    },

    linkToProcess(processId) {
      let url = this.processUrl.replace('${}', encodeURIComponent(processId));
      let target = this.processUrl.startsWith('#') ? '_self' : '_blank';
      return `<code><a href="${url}" target="${target}" class="process-link">${processId}</a></code>`;
    }

  }
});
// CONCATENATED MODULE: ./node_modules/@openeo/vue-components/components/Description.vue?vue&type=script&lang=js&
 /* harmony default export */ var components_Descriptionvue_type_script_lang_js_ = (Descriptionvue_type_script_lang_js_); 
// EXTERNAL MODULE: ./node_modules/@openeo/vue-components/components/Description.vue?vue&type=style&index=0&lang=css&
var Descriptionvue_type_style_index_0_lang_css_ = __webpack_require__("2c44");

// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
var componentNormalizer = __webpack_require__("2877");

// CONCATENATED MODULE: ./node_modules/@openeo/vue-components/components/Description.vue






/* normalize component */

var component = Object(componentNormalizer["a" /* default */])(
  components_Descriptionvue_type_script_lang_js_,
  render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var Description = __webpack_exports__["default"] = (component.exports);

/***/ }),

/***/ "89b6":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.encode = exports.decodeStrict = exports.decode = void 0;
var decode_1 = __webpack_require__("a16e");
var encode_1 = __webpack_require__("051a");
/**
 * Decodes a string with entities.
 *
 * @param data String to decode.
 * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.
 */
function decode(data, level) {
    return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);
}
exports.decode = decode;
/**
 * Decodes a string with entities. Does not allow missing trailing semicolons for entities.
 *
 * @param data String to decode.
 * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.
 */
function decodeStrict(data, level) {
    return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);
}
exports.decodeStrict = decodeStrict;
/**
 * Encodes a string with entities.
 *
 * @param data String to encode.
 * @param level Optional level to encode at. 0 = XML, 1 = HTML. Default is 0.
 */
function encode(data, level) {
    return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);
}
exports.encode = encode;
var encode_2 = __webpack_require__("051a");
Object.defineProperty(exports, "encodeXML", { enumerable: true, get: function () { return encode_2.encodeXML; } });
Object.defineProperty(exports, "encodeHTML", { enumerable: true, get: function () { return encode_2.encodeHTML; } });
Object.defineProperty(exports, "escape", { enumerable: true, get: function () { return encode_2.escape; } });
// Legacy aliases
Object.defineProperty(exports, "encodeHTML4", { enumerable: true, get: function () { return encode_2.encodeHTML; } });
Object.defineProperty(exports, "encodeHTML5", { enumerable: true, get: function () { return encode_2.encodeHTML; } });
var decode_2 = __webpack_require__("a16e");
Object.defineProperty(exports, "decodeXML", { enumerable: true, get: function () { return decode_2.decodeXML; } });
Object.defineProperty(exports, "decodeHTML", { enumerable: true, get: function () { return decode_2.decodeHTML; } });
Object.defineProperty(exports, "decodeHTMLStrict", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });
// Legacy aliases
Object.defineProperty(exports, "decodeHTML4", { enumerable: true, get: function () { return decode_2.decodeHTML; } });
Object.defineProperty(exports, "decodeHTML5", { enumerable: true, get: function () { return decode_2.decodeHTML; } });
Object.defineProperty(exports, "decodeHTML4Strict", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });
Object.defineProperty(exports, "decodeHTML5Strict", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });
Object.defineProperty(exports, "decodeXMLStrict", { enumerable: true, get: function () { return decode_2.decodeXML; } });


/***/ }),

/***/ "a16e":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeHTML = exports.decodeHTMLStrict = exports.decodeXML = void 0;
var entities_json_1 = __importDefault(__webpack_require__("c560"));
var legacy_json_1 = __importDefault(__webpack_require__("b960"));
var xml_json_1 = __importDefault(__webpack_require__("f5f2"));
var decode_codepoint_1 = __importDefault(__webpack_require__("7073"));
exports.decodeXML = getStrictDecoder(xml_json_1.default);
exports.decodeHTMLStrict = getStrictDecoder(entities_json_1.default);
function getStrictDecoder(map) {
    var keys = Object.keys(map).join("|");
    var replace = getReplacer(map);
    keys += "|#[xX][\\da-fA-F]+|#\\d+";
    var re = new RegExp("&(?:" + keys + ");", "g");
    return function (str) { return String(str).replace(re, replace); };
}
var sorter = function (a, b) { return (a < b ? 1 : -1); };
exports.decodeHTML = (function () {
    var legacy = Object.keys(legacy_json_1.default).sort(sorter);
    var keys = Object.keys(entities_json_1.default).sort(sorter);
    for (var i = 0, j = 0; i < keys.length; i++) {
        if (legacy[j] === keys[i]) {
            keys[i] += ";?";
            j++;
        }
        else {
            keys[i] += ";";
        }
    }
    var re = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g");
    var replace = getReplacer(entities_json_1.default);
    function replacer(str) {
        if (str.substr(-1) !== ";")
            str += ";";
        return replace(str);
    }
    //TODO consider creating a merged map
    return function (str) { return String(str).replace(re, replacer); };
})();
function getReplacer(map) {
    return function replace(str) {
        if (str.charAt(1) === "#") {
            var secondChar = str.charAt(2);
            if (secondChar === "X" || secondChar === "x") {
                return decode_codepoint_1.default(parseInt(str.substr(3), 16));
            }
            return decode_codepoint_1.default(parseInt(str.substr(2), 10));
        }
        return map[str.slice(1, -1)];
    };
}


/***/ }),

/***/ "b960":
/***/ (function(module) {

module.exports = JSON.parse("{\"Aacute\":\"\",\"aacute\":\"\",\"Acirc\":\"\",\"acirc\":\"\",\"acute\":\"\",\"AElig\":\"\",\"aelig\":\"\",\"Agrave\":\"\",\"agrave\":\"\",\"amp\":\"&\",\"AMP\":\"&\",\"Aring\":\"\",\"aring\":\"\",\"Atilde\":\"\",\"atilde\":\"\",\"Auml\":\"\",\"auml\":\"\",\"brvbar\":\"\",\"Ccedil\":\"\",\"ccedil\":\"\",\"cedil\":\"\",\"cent\":\"\",\"copy\":\"\",\"COPY\":\"\",\"curren\":\"\",\"deg\":\"\",\"divide\":\"\",\"Eacute\":\"\",\"eacute\":\"\",\"Ecirc\":\"\",\"ecirc\":\"\",\"Egrave\":\"\",\"egrave\":\"\",\"ETH\":\"\",\"eth\":\"\",\"Euml\":\"\",\"euml\":\"\",\"frac12\":\"\",\"frac14\":\"\",\"frac34\":\"\",\"gt\":\">\",\"GT\":\">\",\"Iacute\":\"\",\"iacute\":\"\",\"Icirc\":\"\",\"icirc\":\"\",\"iexcl\":\"\",\"Igrave\":\"\",\"igrave\":\"\",\"iquest\":\"\",\"Iuml\":\"\",\"iuml\":\"\",\"laquo\":\"\",\"lt\":\"<\",\"LT\":\"<\",\"macr\":\"\",\"micro\":\"\",\"middot\":\"\",\"nbsp\":\"\",\"not\":\"\",\"Ntilde\":\"\",\"ntilde\":\"\",\"Oacute\":\"\",\"oacute\":\"\",\"Ocirc\":\"\",\"ocirc\":\"\",\"Ograve\":\"\",\"ograve\":\"\",\"ordf\":\"\",\"ordm\":\"\",\"Oslash\":\"\",\"oslash\":\"\",\"Otilde\":\"\",\"otilde\":\"\",\"Ouml\":\"\",\"ouml\":\"\",\"para\":\"\",\"plusmn\":\"\",\"pound\":\"\",\"quot\":\"\\\"\",\"QUOT\":\"\\\"\",\"raquo\":\"\",\"reg\":\"\",\"REG\":\"\",\"sect\":\"\",\"shy\":\"\",\"sup1\":\"\",\"sup2\":\"\",\"sup3\":\"\",\"szlig\":\"\",\"THORN\":\"\",\"thorn\":\"\",\"times\":\"\",\"Uacute\":\"\",\"uacute\":\"\",\"Ucirc\":\"\",\"ucirc\":\"\",\"Ugrave\":\"\",\"ugrave\":\"\",\"uml\":\"\",\"Uuml\":\"\",\"uuml\":\"\",\"Yacute\":\"\",\"yacute\":\"\",\"yen\":\"\",\"yuml\":\"\"}");

/***/ }),

/***/ "c464":
/***/ (function(module, exports, __webpack_require__) {

"use strict";




var encodeCache = {};


// Create a lookup array where anything but characters in `chars` string
// and alphanumeric chars is percent-encoded.
//
function getEncodeCache(exclude) {
  var i, ch, cache = encodeCache[exclude];
  if (cache) { return cache; }

  cache = encodeCache[exclude] = [];

  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);

    if (/^[0-9a-z]$/i.test(ch)) {
      // always allow unencoded alphanumeric characters
      cache.push(ch);
    } else {
      cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2));
    }
  }

  for (i = 0; i < exclude.length; i++) {
    cache[exclude.charCodeAt(i)] = exclude[i];
  }

  return cache;
}


// Encode unsafe characters with percent-encoding, skipping already
// encoded sequences.
//
//  - string       - string to encode
//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)
//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)
//
function encode(string, exclude, keepEscaped) {
  var i, l, code, nextCode, cache,
      result = '';

  if (typeof exclude !== 'string') {
    // encode(string, keepEscaped)
    keepEscaped  = exclude;
    exclude = encode.defaultChars;
  }

  if (typeof keepEscaped === 'undefined') {
    keepEscaped = true;
  }

  cache = getEncodeCache(exclude);

  for (i = 0, l = string.length; i < l; i++) {
    code = string.charCodeAt(i);

    if (keepEscaped && code === 0x25 /* % */ && i + 2 < l) {
      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
        result += string.slice(i, i + 3);
        i += 2;
        continue;
      }
    }

    if (code < 128) {
      result += cache[code];
      continue;
    }

    if (code >= 0xD800 && code <= 0xDFFF) {
      if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {
        nextCode = string.charCodeAt(i + 1);
        if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {
          result += encodeURIComponent(string[i] + string[i + 1]);
          i++;
          continue;
        }
      }
      result += '%EF%BF%BD';
      continue;
    }

    result += encodeURIComponent(string[i]);
  }

  return result;
}

encode.defaultChars   = ";/?:@&=+$,-_.!~*'()#";
encode.componentChars = "-_.!~*'()";


module.exports = encode;


/***/ }),

/***/ "c560":
/***/ (function(module) {

module.exports = JSON.parse("{\"Aacute\":\"\",\"aacute\":\"\",\"Abreve\":\"\",\"abreve\":\"\",\"ac\":\"\",\"acd\":\"\",\"acE\":\"\",\"Acirc\":\"\",\"acirc\":\"\",\"acute\":\"\",\"Acy\":\"\",\"acy\":\"\",\"AElig\":\"\",\"aelig\":\"\",\"af\":\"\",\"Afr\":\"\",\"afr\":\"\",\"Agrave\":\"\",\"agrave\":\"\",\"alefsym\":\"\",\"aleph\":\"\",\"Alpha\":\"\",\"alpha\":\"\",\"Amacr\":\"\",\"amacr\":\"\",\"amalg\":\"\",\"amp\":\"&\",\"AMP\":\"&\",\"andand\":\"\",\"And\":\"\",\"and\":\"\",\"andd\":\"\",\"andslope\":\"\",\"andv\":\"\",\"ang\":\"\",\"ange\":\"\",\"angle\":\"\",\"angmsdaa\":\"\",\"angmsdab\":\"\",\"angmsdac\":\"\",\"angmsdad\":\"\",\"angmsdae\":\"\",\"angmsdaf\":\"\",\"angmsdag\":\"\",\"angmsdah\":\"\",\"angmsd\":\"\",\"angrt\":\"\",\"angrtvb\":\"\",\"angrtvbd\":\"\",\"angsph\":\"\",\"angst\":\"\",\"angzarr\":\"\",\"Aogon\":\"\",\"aogon\":\"\",\"Aopf\":\"\",\"aopf\":\"\",\"apacir\":\"\",\"ap\":\"\",\"apE\":\"\",\"ape\":\"\",\"apid\":\"\",\"apos\":\"'\",\"ApplyFunction\":\"\",\"approx\":\"\",\"approxeq\":\"\",\"Aring\":\"\",\"aring\":\"\",\"Ascr\":\"\",\"ascr\":\"\",\"Assign\":\"\",\"ast\":\"*\",\"asymp\":\"\",\"asympeq\":\"\",\"Atilde\":\"\",\"atilde\":\"\",\"Auml\":\"\",\"auml\":\"\",\"awconint\":\"\",\"awint\":\"\",\"backcong\":\"\",\"backepsilon\":\"\",\"backprime\":\"\",\"backsim\":\"\",\"backsimeq\":\"\",\"Backslash\":\"\",\"Barv\":\"\",\"barvee\":\"\",\"barwed\":\"\",\"Barwed\":\"\",\"barwedge\":\"\",\"bbrk\":\"\",\"bbrktbrk\":\"\",\"bcong\":\"\",\"Bcy\":\"\",\"bcy\":\"\",\"bdquo\":\"\",\"becaus\":\"\",\"because\":\"\",\"Because\":\"\",\"bemptyv\":\"\",\"bepsi\":\"\",\"bernou\":\"\",\"Bernoullis\":\"\",\"Beta\":\"\",\"beta\":\"\",\"beth\":\"\",\"between\":\"\",\"Bfr\":\"\",\"bfr\":\"\",\"bigcap\":\"\",\"bigcirc\":\"\",\"bigcup\":\"\",\"bigodot\":\"\",\"bigoplus\":\"\",\"bigotimes\":\"\",\"bigsqcup\":\"\",\"bigstar\":\"\",\"bigtriangledown\":\"\",\"bigtriangleup\":\"\",\"biguplus\":\"\",\"bigvee\":\"\",\"bigwedge\":\"\",\"bkarow\":\"\",\"blacklozenge\":\"\",\"blacksquare\":\"\",\"blacktriangle\":\"\",\"blacktriangledown\":\"\",\"blacktriangleleft\":\"\",\"blacktriangleright\":\"\",\"blank\":\"\",\"blk12\":\"\",\"blk14\":\"\",\"blk34\":\"\",\"block\":\"\",\"bne\":\"=\",\"bnequiv\":\"\",\"bNot\":\"\",\"bnot\":\"\",\"Bopf\":\"\",\"bopf\":\"\",\"bot\":\"\",\"bottom\":\"\",\"bowtie\":\"\",\"boxbox\":\"\",\"boxdl\":\"\",\"boxdL\":\"\",\"boxDl\":\"\",\"boxDL\":\"\",\"boxdr\":\"\",\"boxdR\":\"\",\"boxDr\":\"\",\"boxDR\":\"\",\"boxh\":\"\",\"boxH\":\"\",\"boxhd\":\"\",\"boxHd\":\"\",\"boxhD\":\"\",\"boxHD\":\"\",\"boxhu\":\"\",\"boxHu\":\"\",\"boxhU\":\"\",\"boxHU\":\"\",\"boxminus\":\"\",\"boxplus\":\"\",\"boxtimes\":\"\",\"boxul\":\"\",\"boxuL\":\"\",\"boxUl\":\"\",\"boxUL\":\"\",\"boxur\":\"\",\"boxuR\":\"\",\"boxUr\":\"\",\"boxUR\":\"\",\"boxv\":\"\",\"boxV\":\"\",\"boxvh\":\"\",\"boxvH\":\"\",\"boxVh\":\"\",\"boxVH\":\"\",\"boxvl\":\"\",\"boxvL\":\"\",\"boxVl\":\"\",\"boxVL\":\"\",\"boxvr\":\"\",\"boxvR\":\"\",\"boxVr\":\"\",\"boxVR\":\"\",\"bprime\":\"\",\"breve\":\"\",\"Breve\":\"\",\"brvbar\":\"\",\"bscr\":\"\",\"Bscr\":\"\",\"bsemi\":\"\",\"bsim\":\"\",\"bsime\":\"\",\"bsolb\":\"\",\"bsol\":\"\\\\\",\"bsolhsub\":\"\",\"bull\":\"\",\"bullet\":\"\",\"bump\":\"\",\"bumpE\":\"\",\"bumpe\":\"\",\"Bumpeq\":\"\",\"bumpeq\":\"\",\"Cacute\":\"\",\"cacute\":\"\",\"capand\":\"\",\"capbrcup\":\"\",\"capcap\":\"\",\"cap\":\"\",\"Cap\":\"\",\"capcup\":\"\",\"capdot\":\"\",\"CapitalDifferentialD\":\"\",\"caps\":\"\",\"caret\":\"\",\"caron\":\"\",\"Cayleys\":\"\",\"ccaps\":\"\",\"Ccaron\":\"\",\"ccaron\":\"\",\"Ccedil\":\"\",\"ccedil\":\"\",\"Ccirc\":\"\",\"ccirc\":\"\",\"Cconint\":\"\",\"ccups\":\"\",\"ccupssm\":\"\",\"Cdot\":\"\",\"cdot\":\"\",\"cedil\":\"\",\"Cedilla\":\"\",\"cemptyv\":\"\",\"cent\":\"\",\"centerdot\":\"\",\"CenterDot\":\"\",\"cfr\":\"\",\"Cfr\":\"\",\"CHcy\":\"\",\"chcy\":\"\",\"check\":\"\",\"checkmark\":\"\",\"Chi\":\"\",\"chi\":\"\",\"circ\":\"\",\"circeq\":\"\",\"circlearrowleft\":\"\",\"circlearrowright\":\"\",\"circledast\":\"\",\"circledcirc\":\"\",\"circleddash\":\"\",\"CircleDot\":\"\",\"circledR\":\"\",\"circledS\":\"\",\"CircleMinus\":\"\",\"CirclePlus\":\"\",\"CircleTimes\":\"\",\"cir\":\"\",\"cirE\":\"\",\"cire\":\"\",\"cirfnint\":\"\",\"cirmid\":\"\",\"cirscir\":\"\",\"ClockwiseContourIntegral\":\"\",\"CloseCurlyDoubleQuote\":\"\",\"CloseCurlyQuote\":\"\",\"clubs\":\"\",\"clubsuit\":\"\",\"colon\":\":\",\"Colon\":\"\",\"Colone\":\"\",\"colone\":\"\",\"coloneq\":\"\",\"comma\":\",\",\"commat\":\"@\",\"comp\":\"\",\"compfn\":\"\",\"complement\":\"\",\"complexes\":\"\",\"cong\":\"\",\"congdot\":\"\",\"Congruent\":\"\",\"conint\":\"\",\"Conint\":\"\",\"ContourIntegral\":\"\",\"copf\":\"\",\"Copf\":\"\",\"coprod\":\"\",\"Coproduct\":\"\",\"copy\":\"\",\"COPY\":\"\",\"copysr\":\"\",\"CounterClockwiseContourIntegral\":\"\",\"crarr\":\"\",\"cross\":\"\",\"Cross\":\"\",\"Cscr\":\"\",\"cscr\":\"\",\"csub\":\"\",\"csube\":\"\",\"csup\":\"\",\"csupe\":\"\",\"ctdot\":\"\",\"cudarrl\":\"\",\"cudarrr\":\"\",\"cuepr\":\"\",\"cuesc\":\"\",\"cularr\":\"\",\"cularrp\":\"\",\"cupbrcap\":\"\",\"cupcap\":\"\",\"CupCap\":\"\",\"cup\":\"\",\"Cup\":\"\",\"cupcup\":\"\",\"cupdot\":\"\",\"cupor\":\"\",\"cups\":\"\",\"curarr\":\"\",\"curarrm\":\"\",\"curlyeqprec\":\"\",\"curlyeqsucc\":\"\",\"curlyvee\":\"\",\"curlywedge\":\"\",\"curren\":\"\",\"curvearrowleft\":\"\",\"curvearrowright\":\"\",\"cuvee\":\"\",\"cuwed\":\"\",\"cwconint\":\"\",\"cwint\":\"\",\"cylcty\":\"\",\"dagger\":\"\",\"Dagger\":\"\",\"daleth\":\"\",\"darr\":\"\",\"Darr\":\"\",\"dArr\":\"\",\"dash\":\"\",\"Dashv\":\"\",\"dashv\":\"\",\"dbkarow\":\"\",\"dblac\":\"\",\"Dcaron\":\"\",\"dcaron\":\"\",\"Dcy\":\"\",\"dcy\":\"\",\"ddagger\":\"\",\"ddarr\":\"\",\"DD\":\"\",\"dd\":\"\",\"DDotrahd\":\"\",\"ddotseq\":\"\",\"deg\":\"\",\"Del\":\"\",\"Delta\":\"\",\"delta\":\"\",\"demptyv\":\"\",\"dfisht\":\"\",\"Dfr\":\"\",\"dfr\":\"\",\"dHar\":\"\",\"dharl\":\"\",\"dharr\":\"\",\"DiacriticalAcute\":\"\",\"DiacriticalDot\":\"\",\"DiacriticalDoubleAcute\":\"\",\"DiacriticalGrave\":\"`\",\"DiacriticalTilde\":\"\",\"diam\":\"\",\"diamond\":\"\",\"Diamond\":\"\",\"diamondsuit\":\"\",\"diams\":\"\",\"die\":\"\",\"DifferentialD\":\"\",\"digamma\":\"\",\"disin\":\"\",\"div\":\"\",\"divide\":\"\",\"divideontimes\":\"\",\"divonx\":\"\",\"DJcy\":\"\",\"djcy\":\"\",\"dlcorn\":\"\",\"dlcrop\":\"\",\"dollar\":\"$\",\"Dopf\":\"\",\"dopf\":\"\",\"Dot\":\"\",\"dot\":\"\",\"DotDot\":\"\",\"doteq\":\"\",\"doteqdot\":\"\",\"DotEqual\":\"\",\"dotminus\":\"\",\"dotplus\":\"\",\"dotsquare\":\"\",\"doublebarwedge\":\"\",\"DoubleContourIntegral\":\"\",\"DoubleDot\":\"\",\"DoubleDownArrow\":\"\",\"DoubleLeftArrow\":\"\",\"DoubleLeftRightArrow\":\"\",\"DoubleLeftTee\":\"\",\"DoubleLongLeftArrow\":\"\",\"DoubleLongLeftRightArrow\":\"\",\"DoubleLongRightArrow\":\"\",\"DoubleRightArrow\":\"\",\"DoubleRightTee\":\"\",\"DoubleUpArrow\":\"\",\"DoubleUpDownArrow\":\"\",\"DoubleVerticalBar\":\"\",\"DownArrowBar\":\"\",\"downarrow\":\"\",\"DownArrow\":\"\",\"Downarrow\":\"\",\"DownArrowUpArrow\":\"\",\"DownBreve\":\"\",\"downdownarrows\":\"\",\"downharpoonleft\":\"\",\"downharpoonright\":\"\",\"DownLeftRightVector\":\"\",\"DownLeftTeeVector\":\"\",\"DownLeftVectorBar\":\"\",\"DownLeftVector\":\"\",\"DownRightTeeVector\":\"\",\"DownRightVectorBar\":\"\",\"DownRightVector\":\"\",\"DownTeeArrow\":\"\",\"DownTee\":\"\",\"drbkarow\":\"\",\"drcorn\":\"\",\"drcrop\":\"\",\"Dscr\":\"\",\"dscr\":\"\",\"DScy\":\"\",\"dscy\":\"\",\"dsol\":\"\",\"Dstrok\":\"\",\"dstrok\":\"\",\"dtdot\":\"\",\"dtri\":\"\",\"dtrif\":\"\",\"duarr\":\"\",\"duhar\":\"\",\"dwangle\":\"\",\"DZcy\":\"\",\"dzcy\":\"\",\"dzigrarr\":\"\",\"Eacute\":\"\",\"eacute\":\"\",\"easter\":\"\",\"Ecaron\":\"\",\"ecaron\":\"\",\"Ecirc\":\"\",\"ecirc\":\"\",\"ecir\":\"\",\"ecolon\":\"\",\"Ecy\":\"\",\"ecy\":\"\",\"eDDot\":\"\",\"Edot\":\"\",\"edot\":\"\",\"eDot\":\"\",\"ee\":\"\",\"efDot\":\"\",\"Efr\":\"\",\"efr\":\"\",\"eg\":\"\",\"Egrave\":\"\",\"egrave\":\"\",\"egs\":\"\",\"egsdot\":\"\",\"el\":\"\",\"Element\":\"\",\"elinters\":\"\",\"ell\":\"\",\"els\":\"\",\"elsdot\":\"\",\"Emacr\":\"\",\"emacr\":\"\",\"empty\":\"\",\"emptyset\":\"\",\"EmptySmallSquare\":\"\",\"emptyv\":\"\",\"EmptyVerySmallSquare\":\"\",\"emsp13\":\"\",\"emsp14\":\"\",\"emsp\":\"\",\"ENG\":\"\",\"eng\":\"\",\"ensp\":\"\",\"Eogon\":\"\",\"eogon\":\"\",\"Eopf\":\"\",\"eopf\":\"\",\"epar\":\"\",\"eparsl\":\"\",\"eplus\":\"\",\"epsi\":\"\",\"Epsilon\":\"\",\"epsilon\":\"\",\"epsiv\":\"\",\"eqcirc\":\"\",\"eqcolon\":\"\",\"eqsim\":\"\",\"eqslantgtr\":\"\",\"eqslantless\":\"\",\"Equal\":\"\",\"equals\":\"=\",\"EqualTilde\":\"\",\"equest\":\"\",\"Equilibrium\":\"\",\"equiv\":\"\",\"equivDD\":\"\",\"eqvparsl\":\"\",\"erarr\":\"\",\"erDot\":\"\",\"escr\":\"\",\"Escr\":\"\",\"esdot\":\"\",\"Esim\":\"\",\"esim\":\"\",\"Eta\":\"\",\"eta\":\"\",\"ETH\":\"\",\"eth\":\"\",\"Euml\":\"\",\"euml\":\"\",\"euro\":\"\",\"excl\":\"!\",\"exist\":\"\",\"Exists\":\"\",\"expectation\":\"\",\"exponentiale\":\"\",\"ExponentialE\":\"\",\"fallingdotseq\":\"\",\"Fcy\":\"\",\"fcy\":\"\",\"female\":\"\",\"ffilig\":\"\",\"fflig\":\"\",\"ffllig\":\"\",\"Ffr\":\"\",\"ffr\":\"\",\"filig\":\"\",\"FilledSmallSquare\":\"\",\"FilledVerySmallSquare\":\"\",\"fjlig\":\"fj\",\"flat\":\"\",\"fllig\":\"\",\"fltns\":\"\",\"fnof\":\"\",\"Fopf\":\"\",\"fopf\":\"\",\"forall\":\"\",\"ForAll\":\"\",\"fork\":\"\",\"forkv\":\"\",\"Fouriertrf\":\"\",\"fpartint\":\"\",\"frac12\":\"\",\"frac13\":\"\",\"frac14\":\"\",\"frac15\":\"\",\"frac16\":\"\",\"frac18\":\"\",\"frac23\":\"\",\"frac25\":\"\",\"frac34\":\"\",\"frac35\":\"\",\"frac38\":\"\",\"frac45\":\"\",\"frac56\":\"\",\"frac58\":\"\",\"frac78\":\"\",\"frasl\":\"\",\"frown\":\"\",\"fscr\":\"\",\"Fscr\":\"\",\"gacute\":\"\",\"Gamma\":\"\",\"gamma\":\"\",\"Gammad\":\"\",\"gammad\":\"\",\"gap\":\"\",\"Gbreve\":\"\",\"gbreve\":\"\",\"Gcedil\":\"\",\"Gcirc\":\"\",\"gcirc\":\"\",\"Gcy\":\"\",\"gcy\":\"\",\"Gdot\":\"\",\"gdot\":\"\",\"ge\":\"\",\"gE\":\"\",\"gEl\":\"\",\"gel\":\"\",\"geq\":\"\",\"geqq\":\"\",\"geqslant\":\"\",\"gescc\":\"\",\"ges\":\"\",\"gesdot\":\"\",\"gesdoto\":\"\",\"gesdotol\":\"\",\"gesl\":\"\",\"gesles\":\"\",\"Gfr\":\"\",\"gfr\":\"\",\"gg\":\"\",\"Gg\":\"\",\"ggg\":\"\",\"gimel\":\"\",\"GJcy\":\"\",\"gjcy\":\"\",\"gla\":\"\",\"gl\":\"\",\"glE\":\"\",\"glj\":\"\",\"gnap\":\"\",\"gnapprox\":\"\",\"gne\":\"\",\"gnE\":\"\",\"gneq\":\"\",\"gneqq\":\"\",\"gnsim\":\"\",\"Gopf\":\"\",\"gopf\":\"\",\"grave\":\"`\",\"GreaterEqual\":\"\",\"GreaterEqualLess\":\"\",\"GreaterFullEqual\":\"\",\"GreaterGreater\":\"\",\"GreaterLess\":\"\",\"GreaterSlantEqual\":\"\",\"GreaterTilde\":\"\",\"Gscr\":\"\",\"gscr\":\"\",\"gsim\":\"\",\"gsime\":\"\",\"gsiml\":\"\",\"gtcc\":\"\",\"gtcir\":\"\",\"gt\":\">\",\"GT\":\">\",\"Gt\":\"\",\"gtdot\":\"\",\"gtlPar\":\"\",\"gtquest\":\"\",\"gtrapprox\":\"\",\"gtrarr\":\"\",\"gtrdot\":\"\",\"gtreqless\":\"\",\"gtreqqless\":\"\",\"gtrless\":\"\",\"gtrsim\":\"\",\"gvertneqq\":\"\",\"gvnE\":\"\",\"Hacek\":\"\",\"hairsp\":\"\",\"half\":\"\",\"hamilt\":\"\",\"HARDcy\":\"\",\"hardcy\":\"\",\"harrcir\":\"\",\"harr\":\"\",\"hArr\":\"\",\"harrw\":\"\",\"Hat\":\"^\",\"hbar\":\"\",\"Hcirc\":\"\",\"hcirc\":\"\",\"hearts\":\"\",\"heartsuit\":\"\",\"hellip\":\"\",\"hercon\":\"\",\"hfr\":\"\",\"Hfr\":\"\",\"HilbertSpace\":\"\",\"hksearow\":\"\",\"hkswarow\":\"\",\"hoarr\":\"\",\"homtht\":\"\",\"hookleftarrow\":\"\",\"hookrightarrow\":\"\",\"hopf\":\"\",\"Hopf\":\"\",\"horbar\":\"\",\"HorizontalLine\":\"\",\"hscr\":\"\",\"Hscr\":\"\",\"hslash\":\"\",\"Hstrok\":\"\",\"hstrok\":\"\",\"HumpDownHump\":\"\",\"HumpEqual\":\"\",\"hybull\":\"\",\"hyphen\":\"\",\"Iacute\":\"\",\"iacute\":\"\",\"ic\":\"\",\"Icirc\":\"\",\"icirc\":\"\",\"Icy\":\"\",\"icy\":\"\",\"Idot\":\"\",\"IEcy\":\"\",\"iecy\":\"\",\"iexcl\":\"\",\"iff\":\"\",\"ifr\":\"\",\"Ifr\":\"\",\"Igrave\":\"\",\"igrave\":\"\",\"ii\":\"\",\"iiiint\":\"\",\"iiint\":\"\",\"iinfin\":\"\",\"iiota\":\"\",\"IJlig\":\"\",\"ijlig\":\"\",\"Imacr\":\"\",\"imacr\":\"\",\"image\":\"\",\"ImaginaryI\":\"\",\"imagline\":\"\",\"imagpart\":\"\",\"imath\":\"\",\"Im\":\"\",\"imof\":\"\",\"imped\":\"\",\"Implies\":\"\",\"incare\":\"\",\"in\":\"\",\"infin\":\"\",\"infintie\":\"\",\"inodot\":\"\",\"intcal\":\"\",\"int\":\"\",\"Int\":\"\",\"integers\":\"\",\"Integral\":\"\",\"intercal\":\"\",\"Intersection\":\"\",\"intlarhk\":\"\",\"intprod\":\"\",\"InvisibleComma\":\"\",\"InvisibleTimes\":\"\",\"IOcy\":\"\",\"iocy\":\"\",\"Iogon\":\"\",\"iogon\":\"\",\"Iopf\":\"\",\"iopf\":\"\",\"Iota\":\"\",\"iota\":\"\",\"iprod\":\"\",\"iquest\":\"\",\"iscr\":\"\",\"Iscr\":\"\",\"isin\":\"\",\"isindot\":\"\",\"isinE\":\"\",\"isins\":\"\",\"isinsv\":\"\",\"isinv\":\"\",\"it\":\"\",\"Itilde\":\"\",\"itilde\":\"\",\"Iukcy\":\"\",\"iukcy\":\"\",\"Iuml\":\"\",\"iuml\":\"\",\"Jcirc\":\"\",\"jcirc\":\"\",\"Jcy\":\"\",\"jcy\":\"\",\"Jfr\":\"\",\"jfr\":\"\",\"jmath\":\"\",\"Jopf\":\"\",\"jopf\":\"\",\"Jscr\":\"\",\"jscr\":\"\",\"Jsercy\":\"\",\"jsercy\":\"\",\"Jukcy\":\"\",\"jukcy\":\"\",\"Kappa\":\"\",\"kappa\":\"\",\"kappav\":\"\",\"Kcedil\":\"\",\"kcedil\":\"\",\"Kcy\":\"\",\"kcy\":\"\",\"Kfr\":\"\",\"kfr\":\"\",\"kgreen\":\"\",\"KHcy\":\"\",\"khcy\":\"\",\"KJcy\":\"\",\"kjcy\":\"\",\"Kopf\":\"\",\"kopf\":\"\",\"Kscr\":\"\",\"kscr\":\"\",\"lAarr\":\"\",\"Lacute\":\"\",\"lacute\":\"\",\"laemptyv\":\"\",\"lagran\":\"\",\"Lambda\":\"\",\"lambda\":\"\",\"lang\":\"\",\"Lang\":\"\",\"langd\":\"\",\"langle\":\"\",\"lap\":\"\",\"Laplacetrf\":\"\",\"laquo\":\"\",\"larrb\":\"\",\"larrbfs\":\"\",\"larr\":\"\",\"Larr\":\"\",\"lArr\":\"\",\"larrfs\":\"\",\"larrhk\":\"\",\"larrlp\":\"\",\"larrpl\":\"\",\"larrsim\":\"\",\"larrtl\":\"\",\"latail\":\"\",\"lAtail\":\"\",\"lat\":\"\",\"late\":\"\",\"lates\":\"\",\"lbarr\":\"\",\"lBarr\":\"\",\"lbbrk\":\"\",\"lbrace\":\"{\",\"lbrack\":\"[\",\"lbrke\":\"\",\"lbrksld\":\"\",\"lbrkslu\":\"\",\"Lcaron\":\"\",\"lcaron\":\"\",\"Lcedil\":\"\",\"lcedil\":\"\",\"lceil\":\"\",\"lcub\":\"{\",\"Lcy\":\"\",\"lcy\":\"\",\"ldca\":\"\",\"ldquo\":\"\",\"ldquor\":\"\",\"ldrdhar\":\"\",\"ldrushar\":\"\",\"ldsh\":\"\",\"le\":\"\",\"lE\":\"\",\"LeftAngleBracket\":\"\",\"LeftArrowBar\":\"\",\"leftarrow\":\"\",\"LeftArrow\":\"\",\"Leftarrow\":\"\",\"LeftArrowRightArrow\":\"\",\"leftarrowtail\":\"\",\"LeftCeiling\":\"\",\"LeftDoubleBracket\":\"\",\"LeftDownTeeVector\":\"\",\"LeftDownVectorBar\":\"\",\"LeftDownVector\":\"\",\"LeftFloor\":\"\",\"leftharpoondown\":\"\",\"leftharpoonup\":\"\",\"leftleftarrows\":\"\",\"leftrightarrow\":\"\",\"LeftRightArrow\":\"\",\"Leftrightarrow\":\"\",\"leftrightarrows\":\"\",\"leftrightharpoons\":\"\",\"leftrightsquigarrow\":\"\",\"LeftRightVector\":\"\",\"LeftTeeArrow\":\"\",\"LeftTee\":\"\",\"LeftTeeVector\":\"\",\"leftthreetimes\":\"\",\"LeftTriangleBar\":\"\",\"LeftTriangle\":\"\",\"LeftTriangleEqual\":\"\",\"LeftUpDownVector\":\"\",\"LeftUpTeeVector\":\"\",\"LeftUpVectorBar\":\"\",\"LeftUpVector\":\"\",\"LeftVectorBar\":\"\",\"LeftVector\":\"\",\"lEg\":\"\",\"leg\":\"\",\"leq\":\"\",\"leqq\":\"\",\"leqslant\":\"\",\"lescc\":\"\",\"les\":\"\",\"lesdot\":\"\",\"lesdoto\":\"\",\"lesdotor\":\"\",\"lesg\":\"\",\"lesges\":\"\",\"lessapprox\":\"\",\"lessdot\":\"\",\"lesseqgtr\":\"\",\"lesseqqgtr\":\"\",\"LessEqualGreater\":\"\",\"LessFullEqual\":\"\",\"LessGreater\":\"\",\"lessgtr\":\"\",\"LessLess\":\"\",\"lesssim\":\"\",\"LessSlantEqual\":\"\",\"LessTilde\":\"\",\"lfisht\":\"\",\"lfloor\":\"\",\"Lfr\":\"\",\"lfr\":\"\",\"lg\":\"\",\"lgE\":\"\",\"lHar\":\"\",\"lhard\":\"\",\"lharu\":\"\",\"lharul\":\"\",\"lhblk\":\"\",\"LJcy\":\"\",\"ljcy\":\"\",\"llarr\":\"\",\"ll\":\"\",\"Ll\":\"\",\"llcorner\":\"\",\"Lleftarrow\":\"\",\"llhard\":\"\",\"lltri\":\"\",\"Lmidot\":\"\",\"lmidot\":\"\",\"lmoustache\":\"\",\"lmoust\":\"\",\"lnap\":\"\",\"lnapprox\":\"\",\"lne\":\"\",\"lnE\":\"\",\"lneq\":\"\",\"lneqq\":\"\",\"lnsim\":\"\",\"loang\":\"\",\"loarr\":\"\",\"lobrk\":\"\",\"longleftarrow\":\"\",\"LongLeftArrow\":\"\",\"Longleftarrow\":\"\",\"longleftrightarrow\":\"\",\"LongLeftRightArrow\":\"\",\"Longleftrightarrow\":\"\",\"longmapsto\":\"\",\"longrightarrow\":\"\",\"LongRightArrow\":\"\",\"Longrightarrow\":\"\",\"looparrowleft\":\"\",\"looparrowright\":\"\",\"lopar\":\"\",\"Lopf\":\"\",\"lopf\":\"\",\"loplus\":\"\",\"lotimes\":\"\",\"lowast\":\"\",\"lowbar\":\"_\",\"LowerLeftArrow\":\"\",\"LowerRightArrow\":\"\",\"loz\":\"\",\"lozenge\":\"\",\"lozf\":\"\",\"lpar\":\"(\",\"lparlt\":\"\",\"lrarr\":\"\",\"lrcorner\":\"\",\"lrhar\":\"\",\"lrhard\":\"\",\"lrm\":\"\",\"lrtri\":\"\",\"lsaquo\":\"\",\"lscr\":\"\",\"Lscr\":\"\",\"lsh\":\"\",\"Lsh\":\"\",\"lsim\":\"\",\"lsime\":\"\",\"lsimg\":\"\",\"lsqb\":\"[\",\"lsquo\":\"\",\"lsquor\":\"\",\"Lstrok\":\"\",\"lstrok\":\"\",\"ltcc\":\"\",\"ltcir\":\"\",\"lt\":\"<\",\"LT\":\"<\",\"Lt\":\"\",\"ltdot\":\"\",\"lthree\":\"\",\"ltimes\":\"\",\"ltlarr\":\"\",\"ltquest\":\"\",\"ltri\":\"\",\"ltrie\":\"\",\"ltrif\":\"\",\"ltrPar\":\"\",\"lurdshar\":\"\",\"luruhar\":\"\",\"lvertneqq\":\"\",\"lvnE\":\"\",\"macr\":\"\",\"male\":\"\",\"malt\":\"\",\"maltese\":\"\",\"Map\":\"\",\"map\":\"\",\"mapsto\":\"\",\"mapstodown\":\"\",\"mapstoleft\":\"\",\"mapstoup\":\"\",\"marker\":\"\",\"mcomma\":\"\",\"Mcy\":\"\",\"mcy\":\"\",\"mdash\":\"\",\"mDDot\":\"\",\"measuredangle\":\"\",\"MediumSpace\":\"\",\"Mellintrf\":\"\",\"Mfr\":\"\",\"mfr\":\"\",\"mho\":\"\",\"micro\":\"\",\"midast\":\"*\",\"midcir\":\"\",\"mid\":\"\",\"middot\":\"\",\"minusb\":\"\",\"minus\":\"\",\"minusd\":\"\",\"minusdu\":\"\",\"MinusPlus\":\"\",\"mlcp\":\"\",\"mldr\":\"\",\"mnplus\":\"\",\"models\":\"\",\"Mopf\":\"\",\"mopf\":\"\",\"mp\":\"\",\"mscr\":\"\",\"Mscr\":\"\",\"mstpos\":\"\",\"Mu\":\"\",\"mu\":\"\",\"multimap\":\"\",\"mumap\":\"\",\"nabla\":\"\",\"Nacute\":\"\",\"nacute\":\"\",\"nang\":\"\",\"nap\":\"\",\"napE\":\"\",\"napid\":\"\",\"napos\":\"\",\"napprox\":\"\",\"natural\":\"\",\"naturals\":\"\",\"natur\":\"\",\"nbsp\":\"\",\"nbump\":\"\",\"nbumpe\":\"\",\"ncap\":\"\",\"Ncaron\":\"\",\"ncaron\":\"\",\"Ncedil\":\"\",\"ncedil\":\"\",\"ncong\":\"\",\"ncongdot\":\"\",\"ncup\":\"\",\"Ncy\":\"\",\"ncy\":\"\",\"ndash\":\"\",\"nearhk\":\"\",\"nearr\":\"\",\"neArr\":\"\",\"nearrow\":\"\",\"ne\":\"\",\"nedot\":\"\",\"NegativeMediumSpace\":\"\",\"NegativeThickSpace\":\"\",\"NegativeThinSpace\":\"\",\"NegativeVeryThinSpace\":\"\",\"nequiv\":\"\",\"nesear\":\"\",\"nesim\":\"\",\"NestedGreaterGreater\":\"\",\"NestedLessLess\":\"\",\"NewLine\":\"\\n\",\"nexist\":\"\",\"nexists\":\"\",\"Nfr\":\"\",\"nfr\":\"\",\"ngE\":\"\",\"nge\":\"\",\"ngeq\":\"\",\"ngeqq\":\"\",\"ngeqslant\":\"\",\"nges\":\"\",\"nGg\":\"\",\"ngsim\":\"\",\"nGt\":\"\",\"ngt\":\"\",\"ngtr\":\"\",\"nGtv\":\"\",\"nharr\":\"\",\"nhArr\":\"\",\"nhpar\":\"\",\"ni\":\"\",\"nis\":\"\",\"nisd\":\"\",\"niv\":\"\",\"NJcy\":\"\",\"njcy\":\"\",\"nlarr\":\"\",\"nlArr\":\"\",\"nldr\":\"\",\"nlE\":\"\",\"nle\":\"\",\"nleftarrow\":\"\",\"nLeftarrow\":\"\",\"nleftrightarrow\":\"\",\"nLeftrightarrow\":\"\",\"nleq\":\"\",\"nleqq\":\"\",\"nleqslant\":\"\",\"nles\":\"\",\"nless\":\"\",\"nLl\":\"\",\"nlsim\":\"\",\"nLt\":\"\",\"nlt\":\"\",\"nltri\":\"\",\"nltrie\":\"\",\"nLtv\":\"\",\"nmid\":\"\",\"NoBreak\":\"\",\"NonBreakingSpace\":\"\",\"nopf\":\"\",\"Nopf\":\"\",\"Not\":\"\",\"not\":\"\",\"NotCongruent\":\"\",\"NotCupCap\":\"\",\"NotDoubleVerticalBar\":\"\",\"NotElement\":\"\",\"NotEqual\":\"\",\"NotEqualTilde\":\"\",\"NotExists\":\"\",\"NotGreater\":\"\",\"NotGreaterEqual\":\"\",\"NotGreaterFullEqual\":\"\",\"NotGreaterGreater\":\"\",\"NotGreaterLess\":\"\",\"NotGreaterSlantEqual\":\"\",\"NotGreaterTilde\":\"\",\"NotHumpDownHump\":\"\",\"NotHumpEqual\":\"\",\"notin\":\"\",\"notindot\":\"\",\"notinE\":\"\",\"notinva\":\"\",\"notinvb\":\"\",\"notinvc\":\"\",\"NotLeftTriangleBar\":\"\",\"NotLeftTriangle\":\"\",\"NotLeftTriangleEqual\":\"\",\"NotLess\":\"\",\"NotLessEqual\":\"\",\"NotLessGreater\":\"\",\"NotLessLess\":\"\",\"NotLessSlantEqual\":\"\",\"NotLessTilde\":\"\",\"NotNestedGreaterGreater\":\"\",\"NotNestedLessLess\":\"\",\"notni\":\"\",\"notniva\":\"\",\"notnivb\":\"\",\"notnivc\":\"\",\"NotPrecedes\":\"\",\"NotPrecedesEqual\":\"\",\"NotPrecedesSlantEqual\":\"\",\"NotReverseElement\":\"\",\"NotRightTriangleBar\":\"\",\"NotRightTriangle\":\"\",\"NotRightTriangleEqual\":\"\",\"NotSquareSubset\":\"\",\"NotSquareSubsetEqual\":\"\",\"NotSquareSuperset\":\"\",\"NotSquareSupersetEqual\":\"\",\"NotSubset\":\"\",\"NotSubsetEqual\":\"\",\"NotSucceeds\":\"\",\"NotSucceedsEqual\":\"\",\"NotSucceedsSlantEqual\":\"\",\"NotSucceedsTilde\":\"\",\"NotSuperset\":\"\",\"NotSupersetEqual\":\"\",\"NotTilde\":\"\",\"NotTildeEqual\":\"\",\"NotTildeFullEqual\":\"\",\"NotTildeTilde\":\"\",\"NotVerticalBar\":\"\",\"nparallel\":\"\",\"npar\":\"\",\"nparsl\":\"\",\"npart\":\"\",\"npolint\":\"\",\"npr\":\"\",\"nprcue\":\"\",\"nprec\":\"\",\"npreceq\":\"\",\"npre\":\"\",\"nrarrc\":\"\",\"nrarr\":\"\",\"nrArr\":\"\",\"nrarrw\":\"\",\"nrightarrow\":\"\",\"nRightarrow\":\"\",\"nrtri\":\"\",\"nrtrie\":\"\",\"nsc\":\"\",\"nsccue\":\"\",\"nsce\":\"\",\"Nscr\":\"\",\"nscr\":\"\",\"nshortmid\":\"\",\"nshortparallel\":\"\",\"nsim\":\"\",\"nsime\":\"\",\"nsimeq\":\"\",\"nsmid\":\"\",\"nspar\":\"\",\"nsqsube\":\"\",\"nsqsupe\":\"\",\"nsub\":\"\",\"nsubE\":\"\",\"nsube\":\"\",\"nsubset\":\"\",\"nsubseteq\":\"\",\"nsubseteqq\":\"\",\"nsucc\":\"\",\"nsucceq\":\"\",\"nsup\":\"\",\"nsupE\":\"\",\"nsupe\":\"\",\"nsupset\":\"\",\"nsupseteq\":\"\",\"nsupseteqq\":\"\",\"ntgl\":\"\",\"Ntilde\":\"\",\"ntilde\":\"\",\"ntlg\":\"\",\"ntriangleleft\":\"\",\"ntrianglelefteq\":\"\",\"ntriangleright\":\"\",\"ntrianglerighteq\":\"\",\"Nu\":\"\",\"nu\":\"\",\"num\":\"#\",\"numero\":\"\",\"numsp\":\"\",\"nvap\":\"\",\"nvdash\":\"\",\"nvDash\":\"\",\"nVdash\":\"\",\"nVDash\":\"\",\"nvge\":\"\",\"nvgt\":\">\",\"nvHarr\":\"\",\"nvinfin\":\"\",\"nvlArr\":\"\",\"nvle\":\"\",\"nvlt\":\"<\",\"nvltrie\":\"\",\"nvrArr\":\"\",\"nvrtrie\":\"\",\"nvsim\":\"\",\"nwarhk\":\"\",\"nwarr\":\"\",\"nwArr\":\"\",\"nwarrow\":\"\",\"nwnear\":\"\",\"Oacute\":\"\",\"oacute\":\"\",\"oast\":\"\",\"Ocirc\":\"\",\"ocirc\":\"\",\"ocir\":\"\",\"Ocy\":\"\",\"ocy\":\"\",\"odash\":\"\",\"Odblac\":\"\",\"odblac\":\"\",\"odiv\":\"\",\"odot\":\"\",\"odsold\":\"\",\"OElig\":\"\",\"oelig\":\"\",\"ofcir\":\"\",\"Ofr\":\"\",\"ofr\":\"\",\"ogon\":\"\",\"Ograve\":\"\",\"ograve\":\"\",\"ogt\":\"\",\"ohbar\":\"\",\"ohm\":\"\",\"oint\":\"\",\"olarr\":\"\",\"olcir\":\"\",\"olcross\":\"\",\"oline\":\"\",\"olt\":\"\",\"Omacr\":\"\",\"omacr\":\"\",\"Omega\":\"\",\"omega\":\"\",\"Omicron\":\"\",\"omicron\":\"\",\"omid\":\"\",\"ominus\":\"\",\"Oopf\":\"\",\"oopf\":\"\",\"opar\":\"\",\"OpenCurlyDoubleQuote\":\"\",\"OpenCurlyQuote\":\"\",\"operp\":\"\",\"oplus\":\"\",\"orarr\":\"\",\"Or\":\"\",\"or\":\"\",\"ord\":\"\",\"order\":\"\",\"orderof\":\"\",\"ordf\":\"\",\"ordm\":\"\",\"origof\":\"\",\"oror\":\"\",\"orslope\":\"\",\"orv\":\"\",\"oS\":\"\",\"Oscr\":\"\",\"oscr\":\"\",\"Oslash\":\"\",\"oslash\":\"\",\"osol\":\"\",\"Otilde\":\"\",\"otilde\":\"\",\"otimesas\":\"\",\"Otimes\":\"\",\"otimes\":\"\",\"Ouml\":\"\",\"ouml\":\"\",\"ovbar\":\"\",\"OverBar\":\"\",\"OverBrace\":\"\",\"OverBracket\":\"\",\"OverParenthesis\":\"\",\"para\":\"\",\"parallel\":\"\",\"par\":\"\",\"parsim\":\"\",\"parsl\":\"\",\"part\":\"\",\"PartialD\":\"\",\"Pcy\":\"\",\"pcy\":\"\",\"percnt\":\"%\",\"period\":\".\",\"permil\":\"\",\"perp\":\"\",\"pertenk\":\"\",\"Pfr\":\"\",\"pfr\":\"\",\"Phi\":\"\",\"phi\":\"\",\"phiv\":\"\",\"phmmat\":\"\",\"phone\":\"\",\"Pi\":\"\",\"pi\":\"\",\"pitchfork\":\"\",\"piv\":\"\",\"planck\":\"\",\"planckh\":\"\",\"plankv\":\"\",\"plusacir\":\"\",\"plusb\":\"\",\"pluscir\":\"\",\"plus\":\"+\",\"plusdo\":\"\",\"plusdu\":\"\",\"pluse\":\"\",\"PlusMinus\":\"\",\"plusmn\":\"\",\"plussim\":\"\",\"plustwo\":\"\",\"pm\":\"\",\"Poincareplane\":\"\",\"pointint\":\"\",\"popf\":\"\",\"Popf\":\"\",\"pound\":\"\",\"prap\":\"\",\"Pr\":\"\",\"pr\":\"\",\"prcue\":\"\",\"precapprox\":\"\",\"prec\":\"\",\"preccurlyeq\":\"\",\"Precedes\":\"\",\"PrecedesEqual\":\"\",\"PrecedesSlantEqual\":\"\",\"PrecedesTilde\":\"\",\"preceq\":\"\",\"precnapprox\":\"\",\"precneqq\":\"\",\"precnsim\":\"\",\"pre\":\"\",\"prE\":\"\",\"precsim\":\"\",\"prime\":\"\",\"Prime\":\"\",\"primes\":\"\",\"prnap\":\"\",\"prnE\":\"\",\"prnsim\":\"\",\"prod\":\"\",\"Product\":\"\",\"profalar\":\"\",\"profline\":\"\",\"profsurf\":\"\",\"prop\":\"\",\"Proportional\":\"\",\"Proportion\":\"\",\"propto\":\"\",\"prsim\":\"\",\"prurel\":\"\",\"Pscr\":\"\",\"pscr\":\"\",\"Psi\":\"\",\"psi\":\"\",\"puncsp\":\"\",\"Qfr\":\"\",\"qfr\":\"\",\"qint\":\"\",\"qopf\":\"\",\"Qopf\":\"\",\"qprime\":\"\",\"Qscr\":\"\",\"qscr\":\"\",\"quaternions\":\"\",\"quatint\":\"\",\"quest\":\"?\",\"questeq\":\"\",\"quot\":\"\\\"\",\"QUOT\":\"\\\"\",\"rAarr\":\"\",\"race\":\"\",\"Racute\":\"\",\"racute\":\"\",\"radic\":\"\",\"raemptyv\":\"\",\"rang\":\"\",\"Rang\":\"\",\"rangd\":\"\",\"range\":\"\",\"rangle\":\"\",\"raquo\":\"\",\"rarrap\":\"\",\"rarrb\":\"\",\"rarrbfs\":\"\",\"rarrc\":\"\",\"rarr\":\"\",\"Rarr\":\"\",\"rArr\":\"\",\"rarrfs\":\"\",\"rarrhk\":\"\",\"rarrlp\":\"\",\"rarrpl\":\"\",\"rarrsim\":\"\",\"Rarrtl\":\"\",\"rarrtl\":\"\",\"rarrw\":\"\",\"ratail\":\"\",\"rAtail\":\"\",\"ratio\":\"\",\"rationals\":\"\",\"rbarr\":\"\",\"rBarr\":\"\",\"RBarr\":\"\",\"rbbrk\":\"\",\"rbrace\":\"}\",\"rbrack\":\"]\",\"rbrke\":\"\",\"rbrksld\":\"\",\"rbrkslu\":\"\",\"Rcaron\":\"\",\"rcaron\":\"\",\"Rcedil\":\"\",\"rcedil\":\"\",\"rceil\":\"\",\"rcub\":\"}\",\"Rcy\":\"\",\"rcy\":\"\",\"rdca\":\"\",\"rdldhar\":\"\",\"rdquo\":\"\",\"rdquor\":\"\",\"rdsh\":\"\",\"real\":\"\",\"realine\":\"\",\"realpart\":\"\",\"reals\":\"\",\"Re\":\"\",\"rect\":\"\",\"reg\":\"\",\"REG\":\"\",\"ReverseElement\":\"\",\"ReverseEquilibrium\":\"\",\"ReverseUpEquilibrium\":\"\",\"rfisht\":\"\",\"rfloor\":\"\",\"rfr\":\"\",\"Rfr\":\"\",\"rHar\":\"\",\"rhard\":\"\",\"rharu\":\"\",\"rharul\":\"\",\"Rho\":\"\",\"rho\":\"\",\"rhov\":\"\",\"RightAngleBracket\":\"\",\"RightArrowBar\":\"\",\"rightarrow\":\"\",\"RightArrow\":\"\",\"Rightarrow\":\"\",\"RightArrowLeftArrow\":\"\",\"rightarrowtail\":\"\",\"RightCeiling\":\"\",\"RightDoubleBracket\":\"\",\"RightDownTeeVector\":\"\",\"RightDownVectorBar\":\"\",\"RightDownVector\":\"\",\"RightFloor\":\"\",\"rightharpoondown\":\"\",\"rightharpoonup\":\"\",\"rightleftarrows\":\"\",\"rightleftharpoons\":\"\",\"rightrightarrows\":\"\",\"rightsquigarrow\":\"\",\"RightTeeArrow\":\"\",\"RightTee\":\"\",\"RightTeeVector\":\"\",\"rightthreetimes\":\"\",\"RightTriangleBar\":\"\",\"RightTriangle\":\"\",\"RightTriangleEqual\":\"\",\"RightUpDownVector\":\"\",\"RightUpTeeVector\":\"\",\"RightUpVectorBar\":\"\",\"RightUpVector\":\"\",\"RightVectorBar\":\"\",\"RightVector\":\"\",\"ring\":\"\",\"risingdotseq\":\"\",\"rlarr\":\"\",\"rlhar\":\"\",\"rlm\":\"\",\"rmoustache\":\"\",\"rmoust\":\"\",\"rnmid\":\"\",\"roang\":\"\",\"roarr\":\"\",\"robrk\":\"\",\"ropar\":\"\",\"ropf\":\"\",\"Ropf\":\"\",\"roplus\":\"\",\"rotimes\":\"\",\"RoundImplies\":\"\",\"rpar\":\")\",\"rpargt\":\"\",\"rppolint\":\"\",\"rrarr\":\"\",\"Rrightarrow\":\"\",\"rsaquo\":\"\",\"rscr\":\"\",\"Rscr\":\"\",\"rsh\":\"\",\"Rsh\":\"\",\"rsqb\":\"]\",\"rsquo\":\"\",\"rsquor\":\"\",\"rthree\":\"\",\"rtimes\":\"\",\"rtri\":\"\",\"rtrie\":\"\",\"rtrif\":\"\",\"rtriltri\":\"\",\"RuleDelayed\":\"\",\"ruluhar\":\"\",\"rx\":\"\",\"Sacute\":\"\",\"sacute\":\"\",\"sbquo\":\"\",\"scap\":\"\",\"Scaron\":\"\",\"scaron\":\"\",\"Sc\":\"\",\"sc\":\"\",\"sccue\":\"\",\"sce\":\"\",\"scE\":\"\",\"Scedil\":\"\",\"scedil\":\"\",\"Scirc\":\"\",\"scirc\":\"\",\"scnap\":\"\",\"scnE\":\"\",\"scnsim\":\"\",\"scpolint\":\"\",\"scsim\":\"\",\"Scy\":\"\",\"scy\":\"\",\"sdotb\":\"\",\"sdot\":\"\",\"sdote\":\"\",\"searhk\":\"\",\"searr\":\"\",\"seArr\":\"\",\"searrow\":\"\",\"sect\":\"\",\"semi\":\";\",\"seswar\":\"\",\"setminus\":\"\",\"setmn\":\"\",\"sext\":\"\",\"Sfr\":\"\",\"sfr\":\"\",\"sfrown\":\"\",\"sharp\":\"\",\"SHCHcy\":\"\",\"shchcy\":\"\",\"SHcy\":\"\",\"shcy\":\"\",\"ShortDownArrow\":\"\",\"ShortLeftArrow\":\"\",\"shortmid\":\"\",\"shortparallel\":\"\",\"ShortRightArrow\":\"\",\"ShortUpArrow\":\"\",\"shy\":\"\",\"Sigma\":\"\",\"sigma\":\"\",\"sigmaf\":\"\",\"sigmav\":\"\",\"sim\":\"\",\"simdot\":\"\",\"sime\":\"\",\"simeq\":\"\",\"simg\":\"\",\"simgE\":\"\",\"siml\":\"\",\"simlE\":\"\",\"simne\":\"\",\"simplus\":\"\",\"simrarr\":\"\",\"slarr\":\"\",\"SmallCircle\":\"\",\"smallsetminus\":\"\",\"smashp\":\"\",\"smeparsl\":\"\",\"smid\":\"\",\"smile\":\"\",\"smt\":\"\",\"smte\":\"\",\"smtes\":\"\",\"SOFTcy\":\"\",\"softcy\":\"\",\"solbar\":\"\",\"solb\":\"\",\"sol\":\"/\",\"Sopf\":\"\",\"sopf\":\"\",\"spades\":\"\",\"spadesuit\":\"\",\"spar\":\"\",\"sqcap\":\"\",\"sqcaps\":\"\",\"sqcup\":\"\",\"sqcups\":\"\",\"Sqrt\":\"\",\"sqsub\":\"\",\"sqsube\":\"\",\"sqsubset\":\"\",\"sqsubseteq\":\"\",\"sqsup\":\"\",\"sqsupe\":\"\",\"sqsupset\":\"\",\"sqsupseteq\":\"\",\"square\":\"\",\"Square\":\"\",\"SquareIntersection\":\"\",\"SquareSubset\":\"\",\"SquareSubsetEqual\":\"\",\"SquareSuperset\":\"\",\"SquareSupersetEqual\":\"\",\"SquareUnion\":\"\",\"squarf\":\"\",\"squ\":\"\",\"squf\":\"\",\"srarr\":\"\",\"Sscr\":\"\",\"sscr\":\"\",\"ssetmn\":\"\",\"ssmile\":\"\",\"sstarf\":\"\",\"Star\":\"\",\"star\":\"\",\"starf\":\"\",\"straightepsilon\":\"\",\"straightphi\":\"\",\"strns\":\"\",\"sub\":\"\",\"Sub\":\"\",\"subdot\":\"\",\"subE\":\"\",\"sube\":\"\",\"subedot\":\"\",\"submult\":\"\",\"subnE\":\"\",\"subne\":\"\",\"subplus\":\"\",\"subrarr\":\"\",\"subset\":\"\",\"Subset\":\"\",\"subseteq\":\"\",\"subseteqq\":\"\",\"SubsetEqual\":\"\",\"subsetneq\":\"\",\"subsetneqq\":\"\",\"subsim\":\"\",\"subsub\":\"\",\"subsup\":\"\",\"succapprox\":\"\",\"succ\":\"\",\"succcurlyeq\":\"\",\"Succeeds\":\"\",\"SucceedsEqual\":\"\",\"SucceedsSlantEqual\":\"\",\"SucceedsTilde\":\"\",\"succeq\":\"\",\"succnapprox\":\"\",\"succneqq\":\"\",\"succnsim\":\"\",\"succsim\":\"\",\"SuchThat\":\"\",\"sum\":\"\",\"Sum\":\"\",\"sung\":\"\",\"sup1\":\"\",\"sup2\":\"\",\"sup3\":\"\",\"sup\":\"\",\"Sup\":\"\",\"supdot\":\"\",\"supdsub\":\"\",\"supE\":\"\",\"supe\":\"\",\"supedot\":\"\",\"Superset\":\"\",\"SupersetEqual\":\"\",\"suphsol\":\"\",\"suphsub\":\"\",\"suplarr\":\"\",\"supmult\":\"\",\"supnE\":\"\",\"supne\":\"\",\"supplus\":\"\",\"supset\":\"\",\"Supset\":\"\",\"supseteq\":\"\",\"supseteqq\":\"\",\"supsetneq\":\"\",\"supsetneqq\":\"\",\"supsim\":\"\",\"supsub\":\"\",\"supsup\":\"\",\"swarhk\":\"\",\"swarr\":\"\",\"swArr\":\"\",\"swarrow\":\"\",\"swnwar\":\"\",\"szlig\":\"\",\"Tab\":\"\\t\",\"target\":\"\",\"Tau\":\"\",\"tau\":\"\",\"tbrk\":\"\",\"Tcaron\":\"\",\"tcaron\":\"\",\"Tcedil\":\"\",\"tcedil\":\"\",\"Tcy\":\"\",\"tcy\":\"\",\"tdot\":\"\",\"telrec\":\"\",\"Tfr\":\"\",\"tfr\":\"\",\"there4\":\"\",\"therefore\":\"\",\"Therefore\":\"\",\"Theta\":\"\",\"theta\":\"\",\"thetasym\":\"\",\"thetav\":\"\",\"thickapprox\":\"\",\"thicksim\":\"\",\"ThickSpace\":\"\",\"ThinSpace\":\"\",\"thinsp\":\"\",\"thkap\":\"\",\"thksim\":\"\",\"THORN\":\"\",\"thorn\":\"\",\"tilde\":\"\",\"Tilde\":\"\",\"TildeEqual\":\"\",\"TildeFullEqual\":\"\",\"TildeTilde\":\"\",\"timesbar\":\"\",\"timesb\":\"\",\"times\":\"\",\"timesd\":\"\",\"tint\":\"\",\"toea\":\"\",\"topbot\":\"\",\"topcir\":\"\",\"top\":\"\",\"Topf\":\"\",\"topf\":\"\",\"topfork\":\"\",\"tosa\":\"\",\"tprime\":\"\",\"trade\":\"\",\"TRADE\":\"\",\"triangle\":\"\",\"triangledown\":\"\",\"triangleleft\":\"\",\"trianglelefteq\":\"\",\"triangleq\":\"\",\"triangleright\":\"\",\"trianglerighteq\":\"\",\"tridot\":\"\",\"trie\":\"\",\"triminus\":\"\",\"TripleDot\":\"\",\"triplus\":\"\",\"trisb\":\"\",\"tritime\":\"\",\"trpezium\":\"\",\"Tscr\":\"\",\"tscr\":\"\",\"TScy\":\"\",\"tscy\":\"\",\"TSHcy\":\"\",\"tshcy\":\"\",\"Tstrok\":\"\",\"tstrok\":\"\",\"twixt\":\"\",\"twoheadleftarrow\":\"\",\"twoheadrightarrow\":\"\",\"Uacute\":\"\",\"uacute\":\"\",\"uarr\":\"\",\"Uarr\":\"\",\"uArr\":\"\",\"Uarrocir\":\"\",\"Ubrcy\":\"\",\"ubrcy\":\"\",\"Ubreve\":\"\",\"ubreve\":\"\",\"Ucirc\":\"\",\"ucirc\":\"\",\"Ucy\":\"\",\"ucy\":\"\",\"udarr\":\"\",\"Udblac\":\"\",\"udblac\":\"\",\"udhar\":\"\",\"ufisht\":\"\",\"Ufr\":\"\",\"ufr\":\"\",\"Ugrave\":\"\",\"ugrave\":\"\",\"uHar\":\"\",\"uharl\":\"\",\"uharr\":\"\",\"uhblk\":\"\",\"ulcorn\":\"\",\"ulcorner\":\"\",\"ulcrop\":\"\",\"ultri\":\"\",\"Umacr\":\"\",\"umacr\":\"\",\"uml\":\"\",\"UnderBar\":\"_\",\"UnderBrace\":\"\",\"UnderBracket\":\"\",\"UnderParenthesis\":\"\",\"Union\":\"\",\"UnionPlus\":\"\",\"Uogon\":\"\",\"uogon\":\"\",\"Uopf\":\"\",\"uopf\":\"\",\"UpArrowBar\":\"\",\"uparrow\":\"\",\"UpArrow\":\"\",\"Uparrow\":\"\",\"UpArrowDownArrow\":\"\",\"updownarrow\":\"\",\"UpDownArrow\":\"\",\"Updownarrow\":\"\",\"UpEquilibrium\":\"\",\"upharpoonleft\":\"\",\"upharpoonright\":\"\",\"uplus\":\"\",\"UpperLeftArrow\":\"\",\"UpperRightArrow\":\"\",\"upsi\":\"\",\"Upsi\":\"\",\"upsih\":\"\",\"Upsilon\":\"\",\"upsilon\":\"\",\"UpTeeArrow\":\"\",\"UpTee\":\"\",\"upuparrows\":\"\",\"urcorn\":\"\",\"urcorner\":\"\",\"urcrop\":\"\",\"Uring\":\"\",\"uring\":\"\",\"urtri\":\"\",\"Uscr\":\"\",\"uscr\":\"\",\"utdot\":\"\",\"Utilde\":\"\",\"utilde\":\"\",\"utri\":\"\",\"utrif\":\"\",\"uuarr\":\"\",\"Uuml\":\"\",\"uuml\":\"\",\"uwangle\":\"\",\"vangrt\":\"\",\"varepsilon\":\"\",\"varkappa\":\"\",\"varnothing\":\"\",\"varphi\":\"\",\"varpi\":\"\",\"varpropto\":\"\",\"varr\":\"\",\"vArr\":\"\",\"varrho\":\"\",\"varsigma\":\"\",\"varsubsetneq\":\"\",\"varsubsetneqq\":\"\",\"varsupsetneq\":\"\",\"varsupsetneqq\":\"\",\"vartheta\":\"\",\"vartriangleleft\":\"\",\"vartriangleright\":\"\",\"vBar\":\"\",\"Vbar\":\"\",\"vBarv\":\"\",\"Vcy\":\"\",\"vcy\":\"\",\"vdash\":\"\",\"vDash\":\"\",\"Vdash\":\"\",\"VDash\":\"\",\"Vdashl\":\"\",\"veebar\":\"\",\"vee\":\"\",\"Vee\":\"\",\"veeeq\":\"\",\"vellip\":\"\",\"verbar\":\"|\",\"Verbar\":\"\",\"vert\":\"|\",\"Vert\":\"\",\"VerticalBar\":\"\",\"VerticalLine\":\"|\",\"VerticalSeparator\":\"\",\"VerticalTilde\":\"\",\"VeryThinSpace\":\"\",\"Vfr\":\"\",\"vfr\":\"\",\"vltri\":\"\",\"vnsub\":\"\",\"vnsup\":\"\",\"Vopf\":\"\",\"vopf\":\"\",\"vprop\":\"\",\"vrtri\":\"\",\"Vscr\":\"\",\"vscr\":\"\",\"vsubnE\":\"\",\"vsubne\":\"\",\"vsupnE\":\"\",\"vsupne\":\"\",\"Vvdash\":\"\",\"vzigzag\":\"\",\"Wcirc\":\"\",\"wcirc\":\"\",\"wedbar\":\"\",\"wedge\":\"\",\"Wedge\":\"\",\"wedgeq\":\"\",\"weierp\":\"\",\"Wfr\":\"\",\"wfr\":\"\",\"Wopf\":\"\",\"wopf\":\"\",\"wp\":\"\",\"wr\":\"\",\"wreath\":\"\",\"Wscr\":\"\",\"wscr\":\"\",\"xcap\":\"\",\"xcirc\":\"\",\"xcup\":\"\",\"xdtri\":\"\",\"Xfr\":\"\",\"xfr\":\"\",\"xharr\":\"\",\"xhArr\":\"\",\"Xi\":\"\",\"xi\":\"\",\"xlarr\":\"\",\"xlArr\":\"\",\"xmap\":\"\",\"xnis\":\"\",\"xodot\":\"\",\"Xopf\":\"\",\"xopf\":\"\",\"xoplus\":\"\",\"xotime\":\"\",\"xrarr\":\"\",\"xrArr\":\"\",\"Xscr\":\"\",\"xscr\":\"\",\"xsqcup\":\"\",\"xuplus\":\"\",\"xutri\":\"\",\"xvee\":\"\",\"xwedge\":\"\",\"Yacute\":\"\",\"yacute\":\"\",\"YAcy\":\"\",\"yacy\":\"\",\"Ycirc\":\"\",\"ycirc\":\"\",\"Ycy\":\"\",\"ycy\":\"\",\"yen\":\"\",\"Yfr\":\"\",\"yfr\":\"\",\"YIcy\":\"\",\"yicy\":\"\",\"Yopf\":\"\",\"yopf\":\"\",\"Yscr\":\"\",\"yscr\":\"\",\"YUcy\":\"\",\"yucy\":\"\",\"yuml\":\"\",\"Yuml\":\"\",\"Zacute\":\"\",\"zacute\":\"\",\"Zcaron\":\"\",\"zcaron\":\"\",\"Zcy\":\"\",\"zcy\":\"\",\"Zdot\":\"\",\"zdot\":\"\",\"zeetrf\":\"\",\"ZeroWidthSpace\":\"\",\"Zeta\":\"\",\"zeta\":\"\",\"zfr\":\"\",\"Zfr\":\"\",\"ZHcy\":\"\",\"zhcy\":\"\",\"zigrarr\":\"\",\"zopf\":\"\",\"Zopf\":\"\",\"Zscr\":\"\",\"zscr\":\"\",\"zwj\":\"\",\"zwnj\":\"\"}");

/***/ }),

/***/ "ed22":
/***/ (function(module, exports) {

/*! http://mths.be/repeat v0.2.0 by @mathias */
if (!String.prototype.repeat) {
	(function() {
		'use strict'; // needed to support `apply`/`call` with `undefined`/`null`
		var defineProperty = (function() {
			// IE 8 only supports `Object.defineProperty` on DOM elements
			try {
				var object = {};
				var $defineProperty = Object.defineProperty;
				var result = $defineProperty(object, object, object) && $defineProperty;
			} catch(error) {}
			return result;
		}());
		var repeat = function(count) {
			if (this == null) {
				throw TypeError();
			}
			var string = String(this);
			// `ToInteger`
			var n = count ? Number(count) : 0;
			if (n != n) { // better `isNaN`
				n = 0;
			}
			// Account for out-of-bounds indices
			if (n < 0 || n == Infinity) {
				throw RangeError();
			}
			var result = '';
			while (n) {
				if (n % 2 == 1) {
					result += string;
				}
				if (n > 1) {
					string += string;
				}
				n >>= 1;
			}
			return result;
		};
		if (defineProperty) {
			defineProperty(String.prototype, 'repeat', {
				'value': repeat,
				'configurable': true,
				'writable': true
			});
		} else {
			String.prototype.repeat = repeat;
		}
	}());
}


/***/ }),

/***/ "f5f2":
/***/ (function(module) {

module.exports = JSON.parse("{\"amp\":\"&\",\"apos\":\"'\",\"gt\":\">\",\"lt\":\"<\",\"quot\":\"\\\"\"}");

/***/ })

}]);